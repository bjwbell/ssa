// autogenerated from gen/generic.rules: do not edit!
// generated with: cd gen; go run *.go
package ssa

func rewriteValuegeneric(v *Value, config *Config) bool {
	b := v.Block
	switch v.Op {
	case OpAdd64:
		// match: (Add64 (Const64 [c]) (Const64 [d]))
		// cond:
		// result: (Const64 [c+d])
		{
			if v.Args[0].Op != OpConst64 {
				goto end8c46df6f85a11cb1d594076b0e467908
			}
			c := v.Args[0].AuxInt
			if v.Args[1].Op != OpConst64 {
				goto end8c46df6f85a11cb1d594076b0e467908
			}
			d := v.Args[1].AuxInt
			v.Op = OpConst64
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AuxInt = c + d
			return true
		}
		goto end8c46df6f85a11cb1d594076b0e467908
	end8c46df6f85a11cb1d594076b0e467908:
		;
	case OpAddPtr:
		// match: (AddPtr (ConstPtr [c]) (ConstPtr [d]))
		// cond:
		// result: (ConstPtr [c+d])
		{
			if v.Args[0].Op != OpConstPtr {
				goto end145c1aec793b2befff34bc8983b48a38
			}
			c := v.Args[0].AuxInt
			if v.Args[1].Op != OpConstPtr {
				goto end145c1aec793b2befff34bc8983b48a38
			}
			d := v.Args[1].AuxInt
			v.Op = OpConstPtr
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AuxInt = c + d
			return true
		}
		goto end145c1aec793b2befff34bc8983b48a38
	end145c1aec793b2befff34bc8983b48a38:
		;
	case OpAnd16:
		// match: (And16 x x)
		// cond:
		// result: x
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto end69ed6ee2a4fb0491b56c17f3c1926b10
			}
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = x.Type
			v.AddArg(x)
			return true
		}
		goto end69ed6ee2a4fb0491b56c17f3c1926b10
	end69ed6ee2a4fb0491b56c17f3c1926b10:
		;
	case OpAnd32:
		// match: (And32 x x)
		// cond:
		// result: x
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto endbbe8c3c5b2ca8f013aa178d856f3a99c
			}
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = x.Type
			v.AddArg(x)
			return true
		}
		goto endbbe8c3c5b2ca8f013aa178d856f3a99c
	endbbe8c3c5b2ca8f013aa178d856f3a99c:
		;
	case OpAnd64:
		// match: (And64 x x)
		// cond:
		// result: x
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto endc9736bf24d2e5cd8d662e1bcf3164640
			}
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = x.Type
			v.AddArg(x)
			return true
		}
		goto endc9736bf24d2e5cd8d662e1bcf3164640
	endc9736bf24d2e5cd8d662e1bcf3164640:
		;
	case OpAnd8:
		// match: (And8 x x)
		// cond:
		// result: x
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto endeaf127389bd0d4b0e0e297830f8f463b
			}
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = x.Type
			v.AddArg(x)
			return true
		}
		goto endeaf127389bd0d4b0e0e297830f8f463b
	endeaf127389bd0d4b0e0e297830f8f463b:
		;
	case OpArrayIndex:
		// match: (ArrayIndex (Load ptr mem) idx)
		// cond:
		// result: (Load (PtrIndex <v.Type.PtrTo()> ptr idx) mem)
		{
			if v.Args[0].Op != OpLoad {
				goto end4894dd7b58383fee5f8a92be08437c33
			}
			ptr := v.Args[0].Args[0]
			mem := v.Args[0].Args[1]
			idx := v.Args[1]
			v.Op = OpLoad
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v0 := b.NewValue0(v.Line, OpPtrIndex, TypeInvalid)
			v0.Type = v.Type.PtrTo()
			v0.AddArg(ptr)
			v0.AddArg(idx)
			v.AddArg(v0)
			v.AddArg(mem)
			return true
		}
		goto end4894dd7b58383fee5f8a92be08437c33
	end4894dd7b58383fee5f8a92be08437c33:
		;
	case OpCom16:
		// match: (Com16 (Com16 x))
		// cond:
		// result: x
		{
			if v.Args[0].Op != OpCom16 {
				goto end1ea17710dd4dd7ba4e710e0e4c7b5a56
			}
			x := v.Args[0].Args[0]
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = x.Type
			v.AddArg(x)
			return true
		}
		goto end1ea17710dd4dd7ba4e710e0e4c7b5a56
	end1ea17710dd4dd7ba4e710e0e4c7b5a56:
		;
	case OpCom32:
		// match: (Com32 (Com32 x))
		// cond:
		// result: x
		{
			if v.Args[0].Op != OpCom32 {
				goto end9a04ed536496e292c27bef4414128cbf
			}
			x := v.Args[0].Args[0]
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = x.Type
			v.AddArg(x)
			return true
		}
		goto end9a04ed536496e292c27bef4414128cbf
	end9a04ed536496e292c27bef4414128cbf:
		;
	case OpCom64:
		// match: (Com64 (Com64 x))
		// cond:
		// result: x
		{
			if v.Args[0].Op != OpCom64 {
				goto ended44e29d5968f0f7b86972b7bf417ab3
			}
			x := v.Args[0].Args[0]
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = x.Type
			v.AddArg(x)
			return true
		}
		goto ended44e29d5968f0f7b86972b7bf417ab3
	ended44e29d5968f0f7b86972b7bf417ab3:
		;
	case OpCom8:
		// match: (Com8 (Com8 x))
		// cond:
		// result: x
		{
			if v.Args[0].Op != OpCom8 {
				goto end4d92ff3ba567d9afd38fc9ca113602ad
			}
			x := v.Args[0].Args[0]
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = x.Type
			v.AddArg(x)
			return true
		}
		goto end4d92ff3ba567d9afd38fc9ca113602ad
	end4d92ff3ba567d9afd38fc9ca113602ad:
		;
	case OpConstInterface:
		// match: (ConstInterface)
		// cond:
		// result: (IMake     (ConstNil <config.fe.TypeBytePtr()>)     (ConstNil <config.fe.TypeBytePtr()>))
		{
			v.Op = OpIMake
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v0 := b.NewValue0(v.Line, OpConstNil, TypeInvalid)
			v0.Type = config.fe.TypeBytePtr()
			v.AddArg(v0)
			v1 := b.NewValue0(v.Line, OpConstNil, TypeInvalid)
			v1.Type = config.fe.TypeBytePtr()
			v.AddArg(v1)
			return true
		}
		goto end0367bd8f20a320cc41568f2b28657f6b
	end0367bd8f20a320cc41568f2b28657f6b:
		;
	case OpConstSlice:
		// match: (ConstSlice)
		// cond:
		// result: (SliceMake     (ConstNil <config.fe.TypeBytePtr()>)     (ConstPtr <config.fe.TypeUintptr()>)     (ConstPtr <config.fe.TypeUintptr()>))
		{
			v.Op = OpSliceMake
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v0 := b.NewValue0(v.Line, OpConstNil, TypeInvalid)
			v0.Type = config.fe.TypeBytePtr()
			v.AddArg(v0)
			v1 := b.NewValue0(v.Line, OpConstPtr, TypeInvalid)
			v1.Type = config.fe.TypeUintptr()
			v.AddArg(v1)
			v2 := b.NewValue0(v.Line, OpConstPtr, TypeInvalid)
			v2.Type = config.fe.TypeUintptr()
			v.AddArg(v2)
			return true
		}
		goto endfd2d8ffcd55eaf8a5092a20c3ae61ba3
	endfd2d8ffcd55eaf8a5092a20c3ae61ba3:
		;
	case OpConstString:
		// match: (ConstString {s})
		// cond:
		// result: (StringMake     (Addr <config.fe.TypeBytePtr()> {config.fe.StringData(s.(string))}       (SB <config.fe.TypeUintptr()>))     (ConstPtr <config.fe.TypeUintptr()> [int64(len(s.(string)))]))
		{
			s := v.Aux
			v.Op = OpStringMake
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v0 := b.NewValue0(v.Line, OpAddr, TypeInvalid)
			v0.Type = config.fe.TypeBytePtr()
			v0.Aux = config.fe.StringData(s.(string))
			v1 := b.NewValue0(v.Line, OpSB, TypeInvalid)
			v1.Type = config.fe.TypeUintptr()
			v0.AddArg(v1)
			v.AddArg(v0)
			v2 := b.NewValue0(v.Line, OpConstPtr, TypeInvalid)
			v2.Type = config.fe.TypeUintptr()
			v2.AuxInt = int64(len(s.(string)))
			v.AddArg(v2)
			return true
		}
		goto end51a3d96f2d304db9a52f36ee6b29c14e
	end51a3d96f2d304db9a52f36ee6b29c14e:
		;
	case OpEq16:
		// match: (Eq16 x x)
		// cond:
		// result: (ConstBool {true})
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto enda503589f9b617e708a5ad3ddb047809f
			}
			v.Op = OpConstBool
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Aux = true
			return true
		}
		goto enda503589f9b617e708a5ad3ddb047809f
	enda503589f9b617e708a5ad3ddb047809f:
		;
	case OpEq32:
		// match: (Eq32 x x)
		// cond:
		// result: (ConstBool {true})
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto endc94ae3b97d0090257b02152e437b3e17
			}
			v.Op = OpConstBool
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Aux = true
			return true
		}
		goto endc94ae3b97d0090257b02152e437b3e17
	endc94ae3b97d0090257b02152e437b3e17:
		;
	case OpEq64:
		// match: (Eq64 x x)
		// cond:
		// result: (ConstBool {true})
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto end4d21cead60174989467a9c8202dbb91d
			}
			v.Op = OpConstBool
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Aux = true
			return true
		}
		goto end4d21cead60174989467a9c8202dbb91d
	end4d21cead60174989467a9c8202dbb91d:
		;
	case OpEq8:
		// match: (Eq8 x x)
		// cond:
		// result: (ConstBool {true})
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto end73dce8bba164e4f4a1dd701bf8cfb362
			}
			v.Op = OpConstBool
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Aux = true
			return true
		}
		goto end73dce8bba164e4f4a1dd701bf8cfb362
	end73dce8bba164e4f4a1dd701bf8cfb362:
		;
	case OpEqFat:
		// match: (EqFat x y)
		// cond: x.Op == OpConstNil && y.Op != OpConstNil
		// result: (EqFat y x)
		{
			x := v.Args[0]
			y := v.Args[1]
			if !(x.Op == OpConstNil && y.Op != OpConstNil) {
				goto endcea7f7399afcff860c54d82230a9a934
			}
			v.Op = OpEqFat
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AddArg(y)
			v.AddArg(x)
			return true
		}
		goto endcea7f7399afcff860c54d82230a9a934
	endcea7f7399afcff860c54d82230a9a934:
		;
		// match: (EqFat (Load ptr mem) (ConstNil))
		// cond:
		// result: (EqPtr (Load <config.fe.TypeUintptr()> ptr mem) (ConstPtr <config.fe.TypeUintptr()> [0]))
		{
			if v.Args[0].Op != OpLoad {
				goto ende10070e5ddd3dc059674d25ccc6a63b5
			}
			ptr := v.Args[0].Args[0]
			mem := v.Args[0].Args[1]
			if v.Args[1].Op != OpConstNil {
				goto ende10070e5ddd3dc059674d25ccc6a63b5
			}
			v.Op = OpEqPtr
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v0 := b.NewValue0(v.Line, OpLoad, TypeInvalid)
			v0.Type = config.fe.TypeUintptr()
			v0.AddArg(ptr)
			v0.AddArg(mem)
			v.AddArg(v0)
			v1 := b.NewValue0(v.Line, OpConstPtr, TypeInvalid)
			v1.Type = config.fe.TypeUintptr()
			v1.AuxInt = 0
			v.AddArg(v1)
			return true
		}
		goto ende10070e5ddd3dc059674d25ccc6a63b5
	ende10070e5ddd3dc059674d25ccc6a63b5:
		;
	case OpIData:
		// match: (IData (IMake _ data))
		// cond:
		// result: data
		{
			if v.Args[0].Op != OpIMake {
				goto endbfa1bb944cdc07933effb16a35152e12
			}
			data := v.Args[0].Args[1]
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = data.Type
			v.AddArg(data)
			return true
		}
		goto endbfa1bb944cdc07933effb16a35152e12
	endbfa1bb944cdc07933effb16a35152e12:
		;
	case OpITab:
		// match: (ITab (IMake itab _))
		// cond:
		// result: itab
		{
			if v.Args[0].Op != OpIMake {
				goto endfcbb9414a776ff9c8512da3e0f4d8fbd
			}
			itab := v.Args[0].Args[0]
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = itab.Type
			v.AddArg(itab)
			return true
		}
		goto endfcbb9414a776ff9c8512da3e0f4d8fbd
	endfcbb9414a776ff9c8512da3e0f4d8fbd:
		;
	case OpIsInBounds:
		// match: (IsInBounds (Const32 [c]) (Const32 [d]))
		// cond:
		// result: (ConstBool {inBounds32(c,d)})
		{
			if v.Args[0].Op != OpConst32 {
				goto endc3396bf88b56276e1691abe62811dba5
			}
			c := v.Args[0].AuxInt
			if v.Args[1].Op != OpConst32 {
				goto endc3396bf88b56276e1691abe62811dba5
			}
			d := v.Args[1].AuxInt
			v.Op = OpConstBool
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Aux = inBounds32(c, d)
			return true
		}
		goto endc3396bf88b56276e1691abe62811dba5
	endc3396bf88b56276e1691abe62811dba5:
		;
		// match: (IsInBounds (Const64 [c]) (Const64 [d]))
		// cond:
		// result: (ConstBool {inBounds64(c,d)})
		{
			if v.Args[0].Op != OpConst64 {
				goto end0b4b8178a54662835b00bfa503cf879a
			}
			c := v.Args[0].AuxInt
			if v.Args[1].Op != OpConst64 {
				goto end0b4b8178a54662835b00bfa503cf879a
			}
			d := v.Args[1].AuxInt
			v.Op = OpConstBool
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Aux = inBounds64(c, d)
			return true
		}
		goto end0b4b8178a54662835b00bfa503cf879a
	end0b4b8178a54662835b00bfa503cf879a:
		;
		// match: (IsInBounds (ConstPtr [c]) (ConstPtr [d]))
		// cond: config.PtrSize == 4
		// result: (ConstBool {inBounds32(c,d)})
		{
			if v.Args[0].Op != OpConstPtr {
				goto end2c6938f68a67e08dbd96edb1e693e549
			}
			c := v.Args[0].AuxInt
			if v.Args[1].Op != OpConstPtr {
				goto end2c6938f68a67e08dbd96edb1e693e549
			}
			d := v.Args[1].AuxInt
			if !(config.PtrSize == 4) {
				goto end2c6938f68a67e08dbd96edb1e693e549
			}
			v.Op = OpConstBool
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Aux = inBounds32(c, d)
			return true
		}
		goto end2c6938f68a67e08dbd96edb1e693e549
	end2c6938f68a67e08dbd96edb1e693e549:
		;
		// match: (IsInBounds (ConstPtr [c]) (ConstPtr [d]))
		// cond: config.PtrSize == 8
		// result: (ConstBool {inBounds64(c,d)})
		{
			if v.Args[0].Op != OpConstPtr {
				goto end84d6ae817944985f572ecaac51999d6c
			}
			c := v.Args[0].AuxInt
			if v.Args[1].Op != OpConstPtr {
				goto end84d6ae817944985f572ecaac51999d6c
			}
			d := v.Args[1].AuxInt
			if !(config.PtrSize == 8) {
				goto end84d6ae817944985f572ecaac51999d6c
			}
			v.Op = OpConstBool
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Aux = inBounds64(c, d)
			return true
		}
		goto end84d6ae817944985f572ecaac51999d6c
	end84d6ae817944985f572ecaac51999d6c:
		;
	case OpLoad:
		// match: (Load <t> ptr mem)
		// cond: t.IsString()
		// result: (StringMake     (Load <config.fe.TypeBytePtr()> ptr mem)     (Load <config.fe.TypeUintptr()>       (OffPtr <config.fe.TypeUintptr().PtrTo()> [config.PtrSize] ptr)       mem))
		{
			t := v.Type
			ptr := v.Args[0]
			mem := v.Args[1]
			if !(t.IsString()) {
				goto end7c75255555bf9dd796298d9f6eaf9cf2
			}
			v.Op = OpStringMake
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v0 := b.NewValue0(v.Line, OpLoad, TypeInvalid)
			v0.Type = config.fe.TypeBytePtr()
			v0.AddArg(ptr)
			v0.AddArg(mem)
			v.AddArg(v0)
			v1 := b.NewValue0(v.Line, OpLoad, TypeInvalid)
			v1.Type = config.fe.TypeUintptr()
			v2 := b.NewValue0(v.Line, OpOffPtr, TypeInvalid)
			v2.Type = config.fe.TypeUintptr().PtrTo()
			v2.AuxInt = config.PtrSize
			v2.AddArg(ptr)
			v1.AddArg(v2)
			v1.AddArg(mem)
			v.AddArg(v1)
			return true
		}
		goto end7c75255555bf9dd796298d9f6eaf9cf2
	end7c75255555bf9dd796298d9f6eaf9cf2:
		;
		// match: (Load <t> ptr mem)
		// cond: t.IsSlice()
		// result: (SliceMake     (Load <config.fe.TypeBytePtr()> ptr mem)     (Load <config.fe.TypeUintptr()>       (OffPtr <config.fe.TypeUintptr().PtrTo()> [config.PtrSize] ptr)       mem)     (Load <config.fe.TypeUintptr()>       (OffPtr <config.fe.TypeUintptr().PtrTo()> [2*config.PtrSize] ptr)       mem))
		{
			t := v.Type
			ptr := v.Args[0]
			mem := v.Args[1]
			if !(t.IsSlice()) {
				goto end12c46556d962198680eb3238859e3016
			}
			v.Op = OpSliceMake
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v0 := b.NewValue0(v.Line, OpLoad, TypeInvalid)
			v0.Type = config.fe.TypeBytePtr()
			v0.AddArg(ptr)
			v0.AddArg(mem)
			v.AddArg(v0)
			v1 := b.NewValue0(v.Line, OpLoad, TypeInvalid)
			v1.Type = config.fe.TypeUintptr()
			v2 := b.NewValue0(v.Line, OpOffPtr, TypeInvalid)
			v2.Type = config.fe.TypeUintptr().PtrTo()
			v2.AuxInt = config.PtrSize
			v2.AddArg(ptr)
			v1.AddArg(v2)
			v1.AddArg(mem)
			v.AddArg(v1)
			v3 := b.NewValue0(v.Line, OpLoad, TypeInvalid)
			v3.Type = config.fe.TypeUintptr()
			v4 := b.NewValue0(v.Line, OpOffPtr, TypeInvalid)
			v4.Type = config.fe.TypeUintptr().PtrTo()
			v4.AuxInt = 2 * config.PtrSize
			v4.AddArg(ptr)
			v3.AddArg(v4)
			v3.AddArg(mem)
			v.AddArg(v3)
			return true
		}
		goto end12c46556d962198680eb3238859e3016
	end12c46556d962198680eb3238859e3016:
		;
		// match: (Load <t> ptr mem)
		// cond: t.IsInterface()
		// result: (IMake     (Load <config.fe.TypeBytePtr()> ptr mem)     (Load <config.fe.TypeBytePtr()>       (OffPtr <config.fe.TypeBytePtr().PtrTo()> [config.PtrSize] ptr)       mem))
		{
			t := v.Type
			ptr := v.Args[0]
			mem := v.Args[1]
			if !(t.IsInterface()) {
				goto end12671c83ebe3ccbc8e53383765ee7675
			}
			v.Op = OpIMake
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v0 := b.NewValue0(v.Line, OpLoad, TypeInvalid)
			v0.Type = config.fe.TypeBytePtr()
			v0.AddArg(ptr)
			v0.AddArg(mem)
			v.AddArg(v0)
			v1 := b.NewValue0(v.Line, OpLoad, TypeInvalid)
			v1.Type = config.fe.TypeBytePtr()
			v2 := b.NewValue0(v.Line, OpOffPtr, TypeInvalid)
			v2.Type = config.fe.TypeBytePtr().PtrTo()
			v2.AuxInt = config.PtrSize
			v2.AddArg(ptr)
			v1.AddArg(v2)
			v1.AddArg(mem)
			v.AddArg(v1)
			return true
		}
		goto end12671c83ebe3ccbc8e53383765ee7675
	end12671c83ebe3ccbc8e53383765ee7675:
		;
	case OpMul64:
		// match: (Mul64 (Const64 [c]) (Const64 [d]))
		// cond:
		// result: (Const64 [c*d])
		{
			if v.Args[0].Op != OpConst64 {
				goto end7aea1048b5d1230974b97f17238380ae
			}
			c := v.Args[0].AuxInt
			if v.Args[1].Op != OpConst64 {
				goto end7aea1048b5d1230974b97f17238380ae
			}
			d := v.Args[1].AuxInt
			v.Op = OpConst64
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AuxInt = c * d
			return true
		}
		goto end7aea1048b5d1230974b97f17238380ae
	end7aea1048b5d1230974b97f17238380ae:
		;
	case OpMulPtr:
		// match: (MulPtr (ConstPtr [c]) (ConstPtr [d]))
		// cond:
		// result: (ConstPtr [c*d])
		{
			if v.Args[0].Op != OpConstPtr {
				goto end808c190f346658bb1ad032bf37a1059f
			}
			c := v.Args[0].AuxInt
			if v.Args[1].Op != OpConstPtr {
				goto end808c190f346658bb1ad032bf37a1059f
			}
			d := v.Args[1].AuxInt
			v.Op = OpConstPtr
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AuxInt = c * d
			return true
		}
		goto end808c190f346658bb1ad032bf37a1059f
	end808c190f346658bb1ad032bf37a1059f:
		;
	case OpNeq16:
		// match: (Neq16 x x)
		// cond:
		// result: (ConstBool {false})
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto end192755dd3c2be992e9d3deb53794a8d2
			}
			v.Op = OpConstBool
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Aux = false
			return true
		}
		goto end192755dd3c2be992e9d3deb53794a8d2
	end192755dd3c2be992e9d3deb53794a8d2:
		;
	case OpNeq32:
		// match: (Neq32 x x)
		// cond:
		// result: (ConstBool {false})
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto endeb23619fc85950a8df7b31126252c4dd
			}
			v.Op = OpConstBool
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Aux = false
			return true
		}
		goto endeb23619fc85950a8df7b31126252c4dd
	endeb23619fc85950a8df7b31126252c4dd:
		;
	case OpNeq64:
		// match: (Neq64 x x)
		// cond:
		// result: (ConstBool {false})
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto endfc6eea780fb4056afb9e4287076da60c
			}
			v.Op = OpConstBool
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Aux = false
			return true
		}
		goto endfc6eea780fb4056afb9e4287076da60c
	endfc6eea780fb4056afb9e4287076da60c:
		;
	case OpNeq8:
		// match: (Neq8 x x)
		// cond:
		// result: (ConstBool {false})
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto endcccf700d93c6d57765b80f92f7b3fa81
			}
			v.Op = OpConstBool
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Aux = false
			return true
		}
		goto endcccf700d93c6d57765b80f92f7b3fa81
	endcccf700d93c6d57765b80f92f7b3fa81:
		;
	case OpNeqFat:
		// match: (NeqFat x y)
		// cond: x.Op == OpConstNil && y.Op != OpConstNil
		// result: (NeqFat y x)
		{
			x := v.Args[0]
			y := v.Args[1]
			if !(x.Op == OpConstNil && y.Op != OpConstNil) {
				goto end94c68f7dc30c66ed42e507e01c4e5dc7
			}
			v.Op = OpNeqFat
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AddArg(y)
			v.AddArg(x)
			return true
		}
		goto end94c68f7dc30c66ed42e507e01c4e5dc7
	end94c68f7dc30c66ed42e507e01c4e5dc7:
		;
		// match: (NeqFat (Load ptr mem) (ConstNil))
		// cond:
		// result: (NeqPtr (Load <config.fe.TypeUintptr()> ptr mem) (ConstPtr <config.fe.TypeUintptr()> [0]))
		{
			if v.Args[0].Op != OpLoad {
				goto end423eea941d60473e73140e25f5818bfb
			}
			ptr := v.Args[0].Args[0]
			mem := v.Args[0].Args[1]
			if v.Args[1].Op != OpConstNil {
				goto end423eea941d60473e73140e25f5818bfb
			}
			v.Op = OpNeqPtr
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v0 := b.NewValue0(v.Line, OpLoad, TypeInvalid)
			v0.Type = config.fe.TypeUintptr()
			v0.AddArg(ptr)
			v0.AddArg(mem)
			v.AddArg(v0)
			v1 := b.NewValue0(v.Line, OpConstPtr, TypeInvalid)
			v1.Type = config.fe.TypeUintptr()
			v1.AuxInt = 0
			v.AddArg(v1)
			return true
		}
		goto end423eea941d60473e73140e25f5818bfb
	end423eea941d60473e73140e25f5818bfb:
		;
	case OpOr16:
		// match: (Or16 x x)
		// cond:
		// result: x
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto end47a2f25fd31a76807aced3e2b126acdc
			}
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = x.Type
			v.AddArg(x)
			return true
		}
		goto end47a2f25fd31a76807aced3e2b126acdc
	end47a2f25fd31a76807aced3e2b126acdc:
		;
	case OpOr32:
		// match: (Or32 x x)
		// cond:
		// result: x
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto end231e283e568e90bd9a3e6a4fa328c8a4
			}
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = x.Type
			v.AddArg(x)
			return true
		}
		goto end231e283e568e90bd9a3e6a4fa328c8a4
	end231e283e568e90bd9a3e6a4fa328c8a4:
		;
	case OpOr64:
		// match: (Or64 x x)
		// cond:
		// result: x
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto end6b0efc212016dc97d0e3939db04c81d9
			}
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = x.Type
			v.AddArg(x)
			return true
		}
		goto end6b0efc212016dc97d0e3939db04c81d9
	end6b0efc212016dc97d0e3939db04c81d9:
		;
	case OpOr8:
		// match: (Or8 x x)
		// cond:
		// result: x
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto end05295dbfafd6869af79b4daee9fda000
			}
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = x.Type
			v.AddArg(x)
			return true
		}
		goto end05295dbfafd6869af79b4daee9fda000
	end05295dbfafd6869af79b4daee9fda000:
		;
	case OpPtrIndex:
		// match: (PtrIndex <t> ptr idx)
		// cond:
		// result: (AddPtr ptr (MulPtr <config.fe.TypeUintptr()> idx (ConstPtr <config.fe.TypeUintptr()> [t.Elem().Size()])))
		{
			t := v.Type
			ptr := v.Args[0]
			idx := v.Args[1]
			v.Op = OpAddPtr
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AddArg(ptr)
			v0 := b.NewValue0(v.Line, OpMulPtr, TypeInvalid)
			v0.Type = config.fe.TypeUintptr()
			v0.AddArg(idx)
			v1 := b.NewValue0(v.Line, OpConstPtr, TypeInvalid)
			v1.Type = config.fe.TypeUintptr()
			v1.AuxInt = t.Elem().Size()
			v0.AddArg(v1)
			v.AddArg(v0)
			return true
		}
		goto end1e1c5ef80c11231f89a5439cdda98359
	end1e1c5ef80c11231f89a5439cdda98359:
		;
	case OpSliceCap:
		// match: (SliceCap (SliceMake _ _ cap))
		// cond:
		// result: cap
		{
			if v.Args[0].Op != OpSliceMake {
				goto end1bd11616743632b33b410964667fb3c6
			}
			cap := v.Args[0].Args[2]
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = cap.Type
			v.AddArg(cap)
			return true
		}
		goto end1bd11616743632b33b410964667fb3c6
	end1bd11616743632b33b410964667fb3c6:
		;
	case OpSliceLen:
		// match: (SliceLen (SliceMake _ len _))
		// cond:
		// result: len
		{
			if v.Args[0].Op != OpSliceMake {
				goto endebb2090199d13e4c2ae52fb3e778f7fd
			}
			len := v.Args[0].Args[1]
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = len.Type
			v.AddArg(len)
			return true
		}
		goto endebb2090199d13e4c2ae52fb3e778f7fd
	endebb2090199d13e4c2ae52fb3e778f7fd:
		;
	case OpSlicePtr:
		// match: (SlicePtr (SliceMake ptr _ _ ))
		// cond:
		// result: ptr
		{
			if v.Args[0].Op != OpSliceMake {
				goto end526acc0a705137a5d25577499206720b
			}
			ptr := v.Args[0].Args[0]
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = ptr.Type
			v.AddArg(ptr)
			return true
		}
		goto end526acc0a705137a5d25577499206720b
	end526acc0a705137a5d25577499206720b:
		;
	case OpStore:
		// match: (Store [2*config.PtrSize] dst (StringMake ptr len) mem)
		// cond:
		// result: (Store [config.PtrSize]     (OffPtr <config.fe.TypeUintptr().PtrTo()> [config.PtrSize] dst)     len     (Store <TypeMem> [config.PtrSize] dst ptr mem))
		{
			if v.AuxInt != 2*config.PtrSize {
				goto end25ae4fc3dc01583a4adc45067d49940a
			}
			dst := v.Args[0]
			if v.Args[1].Op != OpStringMake {
				goto end25ae4fc3dc01583a4adc45067d49940a
			}
			ptr := v.Args[1].Args[0]
			len := v.Args[1].Args[1]
			mem := v.Args[2]
			v.Op = OpStore
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AuxInt = config.PtrSize
			v0 := b.NewValue0(v.Line, OpOffPtr, TypeInvalid)
			v0.Type = config.fe.TypeUintptr().PtrTo()
			v0.AuxInt = config.PtrSize
			v0.AddArg(dst)
			v.AddArg(v0)
			v.AddArg(len)
			v1 := b.NewValue0(v.Line, OpStore, TypeInvalid)
			v1.Type = TypeMem
			v1.AuxInt = config.PtrSize
			v1.AddArg(dst)
			v1.AddArg(ptr)
			v1.AddArg(mem)
			v.AddArg(v1)
			return true
		}
		goto end25ae4fc3dc01583a4adc45067d49940a
	end25ae4fc3dc01583a4adc45067d49940a:
		;
		// match: (Store [3*config.PtrSize] dst (SliceMake ptr len cap) mem)
		// cond:
		// result: (Store [config.PtrSize]     (OffPtr <config.fe.TypeUintptr().PtrTo()> [2*config.PtrSize] dst)     cap     (Store <TypeMem> [config.PtrSize]       (OffPtr <config.fe.TypeUintptr().PtrTo()> [config.PtrSize] dst)       len       (Store <TypeMem> [config.PtrSize] dst ptr mem)))
		{
			if v.AuxInt != 3*config.PtrSize {
				goto end39ab85d51c8cd7f5d54e3eea4fb79a96
			}
			dst := v.Args[0]
			if v.Args[1].Op != OpSliceMake {
				goto end39ab85d51c8cd7f5d54e3eea4fb79a96
			}
			ptr := v.Args[1].Args[0]
			len := v.Args[1].Args[1]
			cap := v.Args[1].Args[2]
			mem := v.Args[2]
			v.Op = OpStore
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AuxInt = config.PtrSize
			v0 := b.NewValue0(v.Line, OpOffPtr, TypeInvalid)
			v0.Type = config.fe.TypeUintptr().PtrTo()
			v0.AuxInt = 2 * config.PtrSize
			v0.AddArg(dst)
			v.AddArg(v0)
			v.AddArg(cap)
			v1 := b.NewValue0(v.Line, OpStore, TypeInvalid)
			v1.Type = TypeMem
			v1.AuxInt = config.PtrSize
			v2 := b.NewValue0(v.Line, OpOffPtr, TypeInvalid)
			v2.Type = config.fe.TypeUintptr().PtrTo()
			v2.AuxInt = config.PtrSize
			v2.AddArg(dst)
			v1.AddArg(v2)
			v1.AddArg(len)
			v3 := b.NewValue0(v.Line, OpStore, TypeInvalid)
			v3.Type = TypeMem
			v3.AuxInt = config.PtrSize
			v3.AddArg(dst)
			v3.AddArg(ptr)
			v3.AddArg(mem)
			v1.AddArg(v3)
			v.AddArg(v1)
			return true
		}
		goto end39ab85d51c8cd7f5d54e3eea4fb79a96
	end39ab85d51c8cd7f5d54e3eea4fb79a96:
		;
		// match: (Store [2*config.PtrSize] dst (IMake itab data) mem)
		// cond:
		// result: (Store [config.PtrSize]     (OffPtr <config.fe.TypeBytePtr().PtrTo()> [config.PtrSize] dst)     data     (Store <TypeMem> [config.PtrSize] dst itab mem))
		{
			if v.AuxInt != 2*config.PtrSize {
				goto end63b77ae78d92c05d496202e8b6b96ff3
			}
			dst := v.Args[0]
			if v.Args[1].Op != OpIMake {
				goto end63b77ae78d92c05d496202e8b6b96ff3
			}
			itab := v.Args[1].Args[0]
			data := v.Args[1].Args[1]
			mem := v.Args[2]
			v.Op = OpStore
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AuxInt = config.PtrSize
			v0 := b.NewValue0(v.Line, OpOffPtr, TypeInvalid)
			v0.Type = config.fe.TypeBytePtr().PtrTo()
			v0.AuxInt = config.PtrSize
			v0.AddArg(dst)
			v.AddArg(v0)
			v.AddArg(data)
			v1 := b.NewValue0(v.Line, OpStore, TypeInvalid)
			v1.Type = TypeMem
			v1.AuxInt = config.PtrSize
			v1.AddArg(dst)
			v1.AddArg(itab)
			v1.AddArg(mem)
			v.AddArg(v1)
			return true
		}
		goto end63b77ae78d92c05d496202e8b6b96ff3
	end63b77ae78d92c05d496202e8b6b96ff3:
		;
		// match: (Store [size] dst (Load src mem) mem)
		// cond: size > config.IntSize
		// result: (Move [size] dst src mem)
		{
			size := v.AuxInt
			dst := v.Args[0]
			if v.Args[1].Op != OpLoad {
				goto enda18a7163888e2f4fca9f38bae56cef42
			}
			src := v.Args[1].Args[0]
			mem := v.Args[1].Args[1]
			if v.Args[2] != mem {
				goto enda18a7163888e2f4fca9f38bae56cef42
			}
			if !(size > config.IntSize) {
				goto enda18a7163888e2f4fca9f38bae56cef42
			}
			v.Op = OpMove
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AuxInt = size
			v.AddArg(dst)
			v.AddArg(src)
			v.AddArg(mem)
			return true
		}
		goto enda18a7163888e2f4fca9f38bae56cef42
	enda18a7163888e2f4fca9f38bae56cef42:
		;
	case OpStringLen:
		// match: (StringLen (StringMake _ len))
		// cond:
		// result: len
		{
			if v.Args[0].Op != OpStringMake {
				goto end0d922460b7e5ca88324034f4bd6c027c
			}
			len := v.Args[0].Args[1]
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = len.Type
			v.AddArg(len)
			return true
		}
		goto end0d922460b7e5ca88324034f4bd6c027c
	end0d922460b7e5ca88324034f4bd6c027c:
		;
	case OpStringPtr:
		// match: (StringPtr (StringMake ptr _))
		// cond:
		// result: ptr
		{
			if v.Args[0].Op != OpStringMake {
				goto end061edc5d85c73ad909089af2556d9380
			}
			ptr := v.Args[0].Args[0]
			v.Op = OpCopy
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.Type = ptr.Type
			v.AddArg(ptr)
			return true
		}
		goto end061edc5d85c73ad909089af2556d9380
	end061edc5d85c73ad909089af2556d9380:
		;
	case OpStructSelect:
		// match: (StructSelect [idx] (Load ptr mem))
		// cond:
		// result: (Load (OffPtr <v.Type.PtrTo()> [idx] ptr) mem)
		{
			idx := v.AuxInt
			if v.Args[0].Op != OpLoad {
				goto end16fdb45e1dd08feb36e3cc3fb5ed8935
			}
			ptr := v.Args[0].Args[0]
			mem := v.Args[0].Args[1]
			v.Op = OpLoad
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v0 := b.NewValue0(v.Line, OpOffPtr, TypeInvalid)
			v0.Type = v.Type.PtrTo()
			v0.AuxInt = idx
			v0.AddArg(ptr)
			v.AddArg(v0)
			v.AddArg(mem)
			return true
		}
		goto end16fdb45e1dd08feb36e3cc3fb5ed8935
	end16fdb45e1dd08feb36e3cc3fb5ed8935:
		;
	case OpSub16:
		// match: (Sub16 x x)
		// cond:
		// result: (Const16 [0])
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto end83da541391be564f2a08464e674a49e7
			}
			v.Op = OpConst16
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AuxInt = 0
			return true
		}
		goto end83da541391be564f2a08464e674a49e7
	end83da541391be564f2a08464e674a49e7:
		;
	case OpSub32:
		// match: (Sub32 x x)
		// cond:
		// result: (Const32 [0])
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto enda747581e798f199e07f4ad69747cd069
			}
			v.Op = OpConst32
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AuxInt = 0
			return true
		}
		goto enda747581e798f199e07f4ad69747cd069
	enda747581e798f199e07f4ad69747cd069:
		;
	case OpSub64:
		// match: (Sub64 x x)
		// cond:
		// result: (Const64 [0])
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto end0387dc2b7bbe57d4aa54eab5d959da4b
			}
			v.Op = OpConst64
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AuxInt = 0
			return true
		}
		goto end0387dc2b7bbe57d4aa54eab5d959da4b
	end0387dc2b7bbe57d4aa54eab5d959da4b:
		;
	case OpSub8:
		// match: (Sub8 x x)
		// cond:
		// result: (Const8 [0])
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto end4e2ee15ef17611919a1a6b5f80bbfe18
			}
			v.Op = OpConst8
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AuxInt = 0
			return true
		}
		goto end4e2ee15ef17611919a1a6b5f80bbfe18
	end4e2ee15ef17611919a1a6b5f80bbfe18:
		;
	case OpXor16:
		// match: (Xor16 x x)
		// cond:
		// result: (Const16 [0])
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto end5733ceb1903b8140248d8e2cac02fefe
			}
			v.Op = OpConst16
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AuxInt = 0
			return true
		}
		goto end5733ceb1903b8140248d8e2cac02fefe
	end5733ceb1903b8140248d8e2cac02fefe:
		;
	case OpXor32:
		// match: (Xor32 x x)
		// cond:
		// result: (Const32 [0])
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto end268ca02df6515d648e0bfb4e90981d25
			}
			v.Op = OpConst32
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AuxInt = 0
			return true
		}
		goto end268ca02df6515d648e0bfb4e90981d25
	end268ca02df6515d648e0bfb4e90981d25:
		;
	case OpXor64:
		// match: (Xor64 x x)
		// cond:
		// result: (Const64 [0])
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto endaf44e7f9fc58af30df69070953fb45ce
			}
			v.Op = OpConst64
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AuxInt = 0
			return true
		}
		goto endaf44e7f9fc58af30df69070953fb45ce
	endaf44e7f9fc58af30df69070953fb45ce:
		;
	case OpXor8:
		// match: (Xor8 x x)
		// cond:
		// result: (Const8 [0])
		{
			x := v.Args[0]
			if v.Args[1] != x {
				goto end949b3a60b7d181688e6f79f93c782fc8
			}
			v.Op = OpConst8
			v.AuxInt = 0
			v.Aux = nil
			v.resetArgs()
			v.AuxInt = 0
			return true
		}
		goto end949b3a60b7d181688e6f79f93c782fc8
	end949b3a60b7d181688e6f79f93c782fc8:
	}
	return false
}
func rewriteBlockgeneric(b *Block) bool {
	switch b.Kind {
	case BlockIf:
		// match: (If (IsNonNil (GetG)) yes no)
		// cond:
		// result: (Plain nil yes)
		{
			v := b.Control
			if v.Op != OpIsNonNil {
				goto end0f2bb0111a86be0436b44210dbd83a90
			}
			if v.Args[0].Op != OpGetG {
				goto end0f2bb0111a86be0436b44210dbd83a90
			}
			yes := b.Succs[0]
			no := b.Succs[1]
			b.Func.removePredecessor(b, no)
			b.Kind = BlockPlain
			b.Control = nil
			b.Succs = b.Succs[:1]
			b.Succs[0] = yes
			b.Likely = BranchUnknown
			return true
		}
		goto end0f2bb0111a86be0436b44210dbd83a90
	end0f2bb0111a86be0436b44210dbd83a90:
		;
		// match: (If (Not cond) yes no)
		// cond:
		// result: (If cond no yes)
		{
			v := b.Control
			if v.Op != OpNot {
				goto endebe19c1c3c3bec068cdb2dd29ef57f96
			}
			cond := v.Args[0]
			yes := b.Succs[0]
			no := b.Succs[1]
			b.Kind = BlockIf
			b.Control = cond
			b.Succs[0] = no
			b.Succs[1] = yes
			b.Likely *= -1
			return true
		}
		goto endebe19c1c3c3bec068cdb2dd29ef57f96
	endebe19c1c3c3bec068cdb2dd29ef57f96:
		;
		// match: (If (ConstBool {c}) yes no)
		// cond: c.(bool)
		// result: (Plain nil yes)
		{
			v := b.Control
			if v.Op != OpConstBool {
				goto end9ff0273f9b1657f4afc287562ca889f0
			}
			c := v.Aux
			yes := b.Succs[0]
			no := b.Succs[1]
			if !(c.(bool)) {
				goto end9ff0273f9b1657f4afc287562ca889f0
			}
			b.Func.removePredecessor(b, no)
			b.Kind = BlockPlain
			b.Control = nil
			b.Succs = b.Succs[:1]
			b.Succs[0] = yes
			b.Likely = BranchUnknown
			return true
		}
		goto end9ff0273f9b1657f4afc287562ca889f0
	end9ff0273f9b1657f4afc287562ca889f0:
		;
		// match: (If (ConstBool {c}) yes no)
		// cond: !c.(bool)
		// result: (Plain nil no)
		{
			v := b.Control
			if v.Op != OpConstBool {
				goto endf401a4553c3c7c6bed64801da7bba076
			}
			c := v.Aux
			yes := b.Succs[0]
			no := b.Succs[1]
			if !(!c.(bool)) {
				goto endf401a4553c3c7c6bed64801da7bba076
			}
			b.Func.removePredecessor(b, yes)
			b.Kind = BlockPlain
			b.Control = nil
			b.Succs = b.Succs[:1]
			b.Succs[0] = no
			b.Likely = BranchUnknown
			return true
		}
		goto endf401a4553c3c7c6bed64801da7bba076
	endf401a4553c3c7c6bed64801da7bba076:
	}
	return false
}
