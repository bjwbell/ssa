// autogenerated from gen/generic.rules: do not edit!
// generated with: cd gen; go run *.go
package ssa

func rewriteValuegeneric(v *Value, config *Config) bool {
	switch v.Op {
	case OpAdd:
		// match: (Add <t> (Const [c]) (Const [d]))
		// cond: is64BitInt(t)
		// result: (Const [{c.(int64)+d.(int64)}])
		{
			t := v.Type
			if v.Args[0].Op != OpConst {
				goto end8d047ed0ae9537b840adc79ea82c6e05
			}
			c := v.Args[0].Aux
			if v.Args[1].Op != OpConst {
				goto end8d047ed0ae9537b840adc79ea82c6e05
			}
			d := v.Args[1].Aux
			if !(is64BitInt(t)) {
				goto end8d047ed0ae9537b840adc79ea82c6e05
			}
			v.Op = OpConst
			v.Aux = nil
			v.resetArgs()
			v.Aux = c.(int64) + d.(int64)
			return true
		}
		goto end8d047ed0ae9537b840adc79ea82c6e05
	end8d047ed0ae9537b840adc79ea82c6e05:
		;
	case OpArrayIndex:
		// match: (ArrayIndex (Load ptr mem) idx)
		// cond:
		// result: (Load (PtrIndex <ptr.Type.Elem().Elem().PtrTo()> ptr idx) mem)
		{
			if v.Args[0].Op != OpLoad {
				goto end3809f4c52270a76313e4ea26e6f0b753
			}
			ptr := v.Args[0].Args[0]
			mem := v.Args[0].Args[1]
			idx := v.Args[1]
			v.Op = OpLoad
			v.Aux = nil
			v.resetArgs()
			v0 := v.Block.NewValue(OpPtrIndex, TypeInvalid, nil)
			v0.Type = ptr.Type.Elem().Elem().PtrTo()
			v0.AddArg(ptr)
			v0.AddArg(idx)
			v.AddArg(v0)
			v.AddArg(mem)
			return true
		}
		goto end3809f4c52270a76313e4ea26e6f0b753
	end3809f4c52270a76313e4ea26e6f0b753:
		;
	case OpConst:
		// match: (Const <t> [s])
		// cond: t.IsString()
		// result: (StringMake (OffPtr <TypeBytePtr> [2*config.ptrSize] (Global <TypeBytePtr> [config.fe.StringSym(s.(string))])) (Const <config.Uintptr> [int64(len(s.(string)))]))
		{
			t := v.Type
			s := v.Aux
			if !(t.IsString()) {
				goto end8442aa5b3f4e5b840055475883110372
			}
			v.Op = OpStringMake
			v.Aux = nil
			v.resetArgs()
			v0 := v.Block.NewValue(OpOffPtr, TypeInvalid, nil)
			v0.Type = TypeBytePtr
			v0.Aux = 2 * config.ptrSize
			v1 := v.Block.NewValue(OpGlobal, TypeInvalid, nil)
			v1.Type = TypeBytePtr
			v1.Aux = config.fe.StringSym(s.(string))
			v0.AddArg(v1)
			v.AddArg(v0)
			v2 := v.Block.NewValue(OpConst, TypeInvalid, nil)
			v2.Type = config.Uintptr
			v2.Aux = int64(len(s.(string)))
			v.AddArg(v2)
			return true
		}
		goto end8442aa5b3f4e5b840055475883110372
	end8442aa5b3f4e5b840055475883110372:
		;
	case OpIsInBounds:
		// match: (IsInBounds (Const [c]) (Const [d]))
		// cond:
		// result: (Const [inBounds(c.(int64),d.(int64))])
		{
			if v.Args[0].Op != OpConst {
				goto enddbd1a394d9b71ee64335361b8384865c
			}
			c := v.Args[0].Aux
			if v.Args[1].Op != OpConst {
				goto enddbd1a394d9b71ee64335361b8384865c
			}
			d := v.Args[1].Aux
			v.Op = OpConst
			v.Aux = nil
			v.resetArgs()
			v.Aux = inBounds(c.(int64), d.(int64))
			return true
		}
		goto enddbd1a394d9b71ee64335361b8384865c
	enddbd1a394d9b71ee64335361b8384865c:
		;
	case OpLoad:
		// match: (Load <t> ptr mem)
		// cond: t.IsString()
		// result: (StringMake (Load <TypeBytePtr> ptr mem) (Load <config.Uintptr> (OffPtr <TypeBytePtr> [config.ptrSize] ptr) mem))
		{
			t := v.Type
			ptr := v.Args[0]
			mem := v.Args[1]
			if !(t.IsString()) {
				goto endd0afd003b70d726a1c5bbaf51fe06182
			}
			v.Op = OpStringMake
			v.Aux = nil
			v.resetArgs()
			v0 := v.Block.NewValue(OpLoad, TypeInvalid, nil)
			v0.Type = TypeBytePtr
			v0.AddArg(ptr)
			v0.AddArg(mem)
			v.AddArg(v0)
			v1 := v.Block.NewValue(OpLoad, TypeInvalid, nil)
			v1.Type = config.Uintptr
			v2 := v.Block.NewValue(OpOffPtr, TypeInvalid, nil)
			v2.Type = TypeBytePtr
			v2.Aux = config.ptrSize
			v2.AddArg(ptr)
			v1.AddArg(v2)
			v1.AddArg(mem)
			v.AddArg(v1)
			return true
		}
		goto endd0afd003b70d726a1c5bbaf51fe06182
	endd0afd003b70d726a1c5bbaf51fe06182:
		;
	case OpMul:
		// match: (Mul <t> (Const [c]) (Const [d]))
		// cond: is64BitInt(t)
		// result: (Const [{c.(int64)*d.(int64)}])
		{
			t := v.Type
			if v.Args[0].Op != OpConst {
				goto end776610f88cf04f438242d76ed2b14f1c
			}
			c := v.Args[0].Aux
			if v.Args[1].Op != OpConst {
				goto end776610f88cf04f438242d76ed2b14f1c
			}
			d := v.Args[1].Aux
			if !(is64BitInt(t)) {
				goto end776610f88cf04f438242d76ed2b14f1c
			}
			v.Op = OpConst
			v.Aux = nil
			v.resetArgs()
			v.Aux = c.(int64) * d.(int64)
			return true
		}
		goto end776610f88cf04f438242d76ed2b14f1c
	end776610f88cf04f438242d76ed2b14f1c:
		;
	case OpPtrIndex:
		// match: (PtrIndex <t> ptr idx)
		// cond:
		// result: (Add ptr (Mul <config.Uintptr> idx (Const <config.Uintptr> [t.Elem().Size()])))
		{
			t := v.Type
			ptr := v.Args[0]
			idx := v.Args[1]
			v.Op = OpAdd
			v.Aux = nil
			v.resetArgs()
			v.AddArg(ptr)
			v0 := v.Block.NewValue(OpMul, TypeInvalid, nil)
			v0.Type = config.Uintptr
			v0.AddArg(idx)
			v1 := v.Block.NewValue(OpConst, TypeInvalid, nil)
			v1.Type = config.Uintptr
			v1.Aux = t.Elem().Size()
			v0.AddArg(v1)
			v.AddArg(v0)
			return true
		}
		goto end88c7c383675420d1581daeb899039fa8
	end88c7c383675420d1581daeb899039fa8:
		;
	case OpSliceCap:
		// match: (SliceCap (Load ptr mem))
		// cond:
		// result: (Load (Add <ptr.Type> ptr (Const <config.Uintptr> [int64(config.ptrSize*2)])) mem)
		{
			if v.Args[0].Op != OpLoad {
				goto endc871dcd9a720b4290c9cae78fe147c8a
			}
			ptr := v.Args[0].Args[0]
			mem := v.Args[0].Args[1]
			v.Op = OpLoad
			v.Aux = nil
			v.resetArgs()
			v0 := v.Block.NewValue(OpAdd, TypeInvalid, nil)
			v0.Type = ptr.Type
			v0.AddArg(ptr)
			v1 := v.Block.NewValue(OpConst, TypeInvalid, nil)
			v1.Type = config.Uintptr
			v1.Aux = int64(config.ptrSize * 2)
			v0.AddArg(v1)
			v.AddArg(v0)
			v.AddArg(mem)
			return true
		}
		goto endc871dcd9a720b4290c9cae78fe147c8a
	endc871dcd9a720b4290c9cae78fe147c8a:
		;
	case OpSliceLen:
		// match: (SliceLen (Load ptr mem))
		// cond:
		// result: (Load (Add <ptr.Type> ptr (Const <config.Uintptr> [int64(config.ptrSize)])) mem)
		{
			if v.Args[0].Op != OpLoad {
				goto end1eec05e44f5fc8944e7c176f98a74d92
			}
			ptr := v.Args[0].Args[0]
			mem := v.Args[0].Args[1]
			v.Op = OpLoad
			v.Aux = nil
			v.resetArgs()
			v0 := v.Block.NewValue(OpAdd, TypeInvalid, nil)
			v0.Type = ptr.Type
			v0.AddArg(ptr)
			v1 := v.Block.NewValue(OpConst, TypeInvalid, nil)
			v1.Type = config.Uintptr
			v1.Aux = int64(config.ptrSize)
			v0.AddArg(v1)
			v.AddArg(v0)
			v.AddArg(mem)
			return true
		}
		goto end1eec05e44f5fc8944e7c176f98a74d92
	end1eec05e44f5fc8944e7c176f98a74d92:
		;
	case OpSlicePtr:
		// match: (SlicePtr (Load ptr mem))
		// cond:
		// result: (Load ptr mem)
		{
			if v.Args[0].Op != OpLoad {
				goto end459613b83f95b65729d45c2ed663a153
			}
			ptr := v.Args[0].Args[0]
			mem := v.Args[0].Args[1]
			v.Op = OpLoad
			v.Aux = nil
			v.resetArgs()
			v.AddArg(ptr)
			v.AddArg(mem)
			return true
		}
		goto end459613b83f95b65729d45c2ed663a153
	end459613b83f95b65729d45c2ed663a153:
		;
	case OpStore:
		// match: (Store dst (Load <t> src mem) mem)
		// cond: t.Size() > 8
		// result: (Move [t.Size()] dst src mem)
		{
			dst := v.Args[0]
			if v.Args[1].Op != OpLoad {
				goto end324ffb6d2771808da4267f62c854e9c8
			}
			t := v.Args[1].Type
			src := v.Args[1].Args[0]
			mem := v.Args[1].Args[1]
			if v.Args[2] != v.Args[1].Args[1] {
				goto end324ffb6d2771808da4267f62c854e9c8
			}
			if !(t.Size() > 8) {
				goto end324ffb6d2771808da4267f62c854e9c8
			}
			v.Op = OpMove
			v.Aux = nil
			v.resetArgs()
			v.Aux = t.Size()
			v.AddArg(dst)
			v.AddArg(src)
			v.AddArg(mem)
			return true
		}
		goto end324ffb6d2771808da4267f62c854e9c8
	end324ffb6d2771808da4267f62c854e9c8:
		;
		// match: (Store dst str mem)
		// cond: str.Type.IsString()
		// result: (Store (OffPtr <TypeBytePtr> [config.ptrSize] dst) (StringLen <config.Uintptr> str) (Store <TypeMem> dst (StringPtr <TypeBytePtr> str) mem))
		{
			dst := v.Args[0]
			str := v.Args[1]
			mem := v.Args[2]
			if !(str.Type.IsString()) {
				goto end410559d97aed8018f820cd88723de442
			}
			v.Op = OpStore
			v.Aux = nil
			v.resetArgs()
			v0 := v.Block.NewValue(OpOffPtr, TypeInvalid, nil)
			v0.Type = TypeBytePtr
			v0.Aux = config.ptrSize
			v0.AddArg(dst)
			v.AddArg(v0)
			v1 := v.Block.NewValue(OpStringLen, TypeInvalid, nil)
			v1.Type = config.Uintptr
			v1.AddArg(str)
			v.AddArg(v1)
			v2 := v.Block.NewValue(OpStore, TypeInvalid, nil)
			v2.Type = TypeMem
			v2.AddArg(dst)
			v3 := v.Block.NewValue(OpStringPtr, TypeInvalid, nil)
			v3.Type = TypeBytePtr
			v3.AddArg(str)
			v2.AddArg(v3)
			v2.AddArg(mem)
			v.AddArg(v2)
			return true
		}
		goto end410559d97aed8018f820cd88723de442
	end410559d97aed8018f820cd88723de442:
		;
	case OpStringLen:
		// match: (StringLen (StringMake _ len))
		// cond:
		// result: len
		{
			if v.Args[0].Op != OpStringMake {
				goto end0d922460b7e5ca88324034f4bd6c027c
			}
			len := v.Args[0].Args[1]
			v.Op = len.Op
			v.Aux = len.Aux
			v.resetArgs()
			v.AddArgs(len.Args...)
			return true
		}
		goto end0d922460b7e5ca88324034f4bd6c027c
	end0d922460b7e5ca88324034f4bd6c027c:
		;
	case OpStringPtr:
		// match: (StringPtr (StringMake ptr _))
		// cond:
		// result: ptr
		{
			if v.Args[0].Op != OpStringMake {
				goto end061edc5d85c73ad909089af2556d9380
			}
			ptr := v.Args[0].Args[0]
			v.Op = ptr.Op
			v.Aux = ptr.Aux
			v.resetArgs()
			v.AddArgs(ptr.Args...)
			return true
		}
		goto end061edc5d85c73ad909089af2556d9380
	end061edc5d85c73ad909089af2556d9380:
	}
	return false
}
func rewriteBlockgeneric(b *Block) bool {
	switch b.Kind {
	case BlockIf:
		// match: (If (Const [c]) yes no)
		// cond: c.(bool)
		// result: (Plain nil yes)
		{
			v := b.Control
			if v.Op != OpConst {
				goto end60cde11c1be8092f493d9cda982445ca
			}
			c := v.Aux
			yes := b.Succs[0]
			no := b.Succs[1]
			if !(c.(bool)) {
				goto end60cde11c1be8092f493d9cda982445ca
			}
			removePredecessor(b, no)
			b.Kind = BlockPlain
			b.Control = nil
			b.Succs = b.Succs[:1]
			b.Succs[0] = yes
			return true
		}
		goto end60cde11c1be8092f493d9cda982445ca
	end60cde11c1be8092f493d9cda982445ca:
		;
		// match: (If (Const [c]) yes no)
		// cond: !c.(bool)
		// result: (Plain nil no)
		{
			v := b.Control
			if v.Op != OpConst {
				goto endf2a5efbfd2d40dead087c33685c8f30b
			}
			c := v.Aux
			yes := b.Succs[0]
			no := b.Succs[1]
			if !(!c.(bool)) {
				goto endf2a5efbfd2d40dead087c33685c8f30b
			}
			removePredecessor(b, yes)
			b.Kind = BlockPlain
			b.Control = nil
			b.Succs = b.Succs[:1]
			b.Succs[0] = no
			return true
		}
		goto endf2a5efbfd2d40dead087c33685c8f30b
	endf2a5efbfd2d40dead087c33685c8f30b:
	}
	return false
}
