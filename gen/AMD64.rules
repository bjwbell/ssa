// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// x86 register conventions:
//  - Integer types live in the low portion of registers.  Upper portions are junk.
//  - Boolean types use the low-order byte of a register.  Upper bytes are junk.
//  - We do not use AH,BH,CH,DH registers.
//  - Floating-point types will live in the low natural slot of an sse2 register.
//    Unused portions are junk.

// Lowering arithmetic
(Add64 x y) -> (ADDQ x y)
(AddPtr x y) -> (ADDQ x y)
(Add32 x y) -> (ADDL x y)
(Add16 x y) -> (ADDW x y)
(Add8 x y) -> (ADDB x y)

(Sub64 x y) -> (SUBQ x y)
(Sub32 x y) -> (SUBL x y)
(Sub16 x y) -> (SUBW x y)
(Sub8 x y) -> (SUBB x y)

(Mul64 x y) -> (MULQ x y)
(MulPtr x y) -> (MULQ x y)
(Mul32 x y) -> (MULL x y)
(Mul16 x y) -> (MULW x y)
// Note: we use 16-bit multiply instructions for 8-bit multiplies because
// the 16-bit multiply instructions are more forgiving (they operate on
// any register instead of just AX/DX).
(Mul8 x y) -> (MULW x y)

(And64 x y) -> (ANDQ x y)
(And32 x y) -> (ANDL x y)
(And16 x y) -> (ANDW x y)
(And8 x y) -> (ANDB x y)

(Or64 x y) -> (ORQ x y)
(Or32 x y) -> (ORL x y)
(Or16 x y) -> (ORW x y)
(Or8 x y) -> (ORB x y)

(Xor64 x y) -> (XORQ x y)
(Xor32 x y) -> (XORL x y)
(Xor16 x y) -> (XORW x y)
(Xor8 x y) -> (XORB x y)

(Neg64 x) -> (NEGQ x)
(Neg32 x) -> (NEGL x)
(Neg16 x) -> (NEGW x)
(Neg8 x) -> (NEGB x)

(Com64 x) -> (NOTQ x)
(Com32 x) -> (NOTL x)
(Com16 x) -> (NOTW x)
(Com8 x) -> (NOTB x)

// Note: we always extend to 64 bits even though some ops don't need that many result bits.
(SignExt8to16 x) -> (MOVBQSX x)
(SignExt8to32 x) -> (MOVBQSX x)
(SignExt8to64 x) -> (MOVBQSX x)
(SignExt16to32 x) -> (MOVWQSX x)
(SignExt16to64 x) -> (MOVWQSX x)
(SignExt32to64 x) -> (MOVLQSX x)

(ZeroExt8to16 x) -> (MOVBQZX x)
(ZeroExt8to32 x) -> (MOVBQZX x)
(ZeroExt8to64 x) -> (MOVBQZX x)
(ZeroExt16to32 x) -> (MOVWQZX x)
(ZeroExt16to64 x) -> (MOVWQZX x)
(ZeroExt32to64 x) -> (MOVLQZX x)

// Because we ignore high parts of registers, truncates are just copies.
(Trunc16to8 x) -> (Copy x)
(Trunc32to8 x) -> (Copy x)
(Trunc32to16 x) -> (Copy x)
(Trunc64to8 x) -> (Copy x)
(Trunc64to16 x) -> (Copy x)
(Trunc64to32 x) -> (Copy x)

// Lowering shifts
// Unsigned shifts need to return 0 if shift amount is >= width of shifted value.
//   result = (arg << shift) & (shift >= argbits ? 0 : 0xffffffffffffffff)
// Note: for small shifts we generate 32 bits of mask even when we don't need it all.
(Lsh64x64 <t> x y) -> (ANDQ (SHLQ <t> x y) (SBBQcarrymask <t> (CMPQconst <TypeFlags> [64] y)))
(Lsh64x32 <t> x y) -> (ANDQ (SHLQ <t> x y) (SBBQcarrymask <t> (CMPLconst <TypeFlags> [64] y)))
(Lsh64x16 <t> x y) -> (ANDQ (SHLQ <t> x y) (SBBQcarrymask <t> (CMPWconst <TypeFlags> [64] y)))
(Lsh64x8 <t> x y)  -> (ANDQ (SHLQ <t> x y) (SBBQcarrymask <t> (CMPBconst <TypeFlags> [64] y)))

(Lsh32x64 <t> x y) -> (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMPQconst <TypeFlags> [32] y)))
(Lsh32x32 <t> x y) -> (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMPLconst <TypeFlags> [32] y)))
(Lsh32x16 <t> x y) -> (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMPWconst <TypeFlags> [32] y)))
(Lsh32x8 <t> x y)  -> (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMPBconst <TypeFlags> [32] y)))

(Lsh16x64 <t> x y) -> (ANDW (SHLW <t> x y) (SBBLcarrymask <t> (CMPQconst <TypeFlags> [16] y)))
(Lsh16x32 <t> x y) -> (ANDW (SHLW <t> x y) (SBBLcarrymask <t> (CMPLconst <TypeFlags> [16] y)))
(Lsh16x16 <t> x y) -> (ANDW (SHLW <t> x y) (SBBLcarrymask <t> (CMPWconst <TypeFlags> [16] y)))
(Lsh16x8 <t> x y)  -> (ANDW (SHLW <t> x y) (SBBLcarrymask <t> (CMPBconst <TypeFlags> [16] y)))

(Lsh8x64 <t> x y)  -> (ANDB (SHLB <t> x y) (SBBLcarrymask <t> (CMPQconst <TypeFlags> [8] y)))
(Lsh8x32 <t> x y)  -> (ANDB (SHLB <t> x y) (SBBLcarrymask <t> (CMPLconst <TypeFlags> [8] y)))
(Lsh8x16 <t> x y)  -> (ANDB (SHLB <t> x y) (SBBLcarrymask <t> (CMPWconst <TypeFlags> [8] y)))
(Lsh8x8 <t> x y)   -> (ANDB (SHLB <t> x y) (SBBLcarrymask <t> (CMPBconst <TypeFlags> [8] y)))

(Rsh64Ux64 <t> x y) -> (ANDQ (SHRQ <t> x y) (SBBQcarrymask <t> (CMPQconst <TypeFlags> [64] y)))
(Rsh64Ux32 <t> x y) -> (ANDQ (SHRQ <t> x y) (SBBQcarrymask <t> (CMPLconst <TypeFlags> [64] y)))
(Rsh64Ux16 <t> x y) -> (ANDQ (SHRQ <t> x y) (SBBQcarrymask <t> (CMPWconst <TypeFlags> [64] y)))
(Rsh64Ux8 <t> x y)  -> (ANDQ (SHRQ <t> x y) (SBBQcarrymask <t> (CMPBconst <TypeFlags> [64] y)))

(Rsh32Ux64 <t> x y) -> (ANDL (SHRL <t> x y) (SBBLcarrymask <t> (CMPQconst <TypeFlags> [32] y)))
(Rsh32Ux32 <t> x y) -> (ANDL (SHRL <t> x y) (SBBLcarrymask <t> (CMPLconst <TypeFlags> [32] y)))
(Rsh32Ux16 <t> x y) -> (ANDL (SHRL <t> x y) (SBBLcarrymask <t> (CMPWconst <TypeFlags> [32] y)))
(Rsh32Ux8 <t> x y)  -> (ANDL (SHRL <t> x y) (SBBLcarrymask <t> (CMPBconst <TypeFlags> [32] y)))

(Rsh16Ux64 <t> x y) -> (ANDW (SHRW <t> x y) (SBBLcarrymask <t> (CMPQconst <TypeFlags> [16] y)))
(Rsh16Ux32 <t> x y) -> (ANDW (SHRW <t> x y) (SBBLcarrymask <t> (CMPLconst <TypeFlags> [16] y)))
(Rsh16Ux16 <t> x y) -> (ANDW (SHRW <t> x y) (SBBLcarrymask <t> (CMPWconst <TypeFlags> [16] y)))
(Rsh16Ux8 <t> x y)  -> (ANDW (SHRW <t> x y) (SBBLcarrymask <t> (CMPBconst <TypeFlags> [16] y)))

(Rsh8Ux64 <t> x y)  -> (ANDB (SHRB <t> x y) (SBBLcarrymask <t> (CMPQconst <TypeFlags> [8] y)))
(Rsh8Ux32 <t> x y)  -> (ANDB (SHRB <t> x y) (SBBLcarrymask <t> (CMPLconst <TypeFlags> [8] y)))
(Rsh8Ux16 <t> x y)  -> (ANDB (SHRB <t> x y) (SBBLcarrymask <t> (CMPWconst <TypeFlags> [8] y)))
(Rsh8Ux8 <t> x y)   -> (ANDB (SHRB <t> x y) (SBBLcarrymask <t> (CMPBconst <TypeFlags> [8] y)))

// Signed right shift needs to return 0/-1 if shift amount is >= width of shifted value.
// We implement this by setting the shift value to -1 (all ones) if the shift value is >= width.
// Note: for small shift widths we generate 32 bits of mask even when we don't need it all.
(Rsh64x64 <t> x y) -> (SARQ <t> x (ORQ <y.Type> y (NOTQ <y.Type> (SBBQcarrymask <y.Type> (CMPQconst <TypeFlags> [64] y)))))
(Rsh64x32 <t> x y) -> (SARQ <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPLconst <TypeFlags> [64] y)))))
(Rsh64x16 <t> x y) -> (SARQ <t> x (ORW <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPWconst <TypeFlags> [64] y)))))
(Rsh64x8 <t> x y)  -> (SARQ <t> x (ORB <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPBconst <TypeFlags> [64] y)))))

(Rsh32x64 <t> x y) -> (SARL <t> x (ORQ <y.Type> y (NOTQ <y.Type> (SBBQcarrymask <y.Type> (CMPQconst <TypeFlags> [32] y)))))
(Rsh32x32 <t> x y) -> (SARL <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPLconst <TypeFlags> [32] y)))))
(Rsh32x16 <t> x y) -> (SARL <t> x (ORW <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPWconst <TypeFlags> [32] y)))))
(Rsh32x8 <t> x y)  -> (SARL <t> x (ORB <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPBconst <TypeFlags> [32] y)))))

(Rsh16x64 <t> x y) -> (SARW <t> x (ORQ <y.Type> y (NOTQ <y.Type> (SBBQcarrymask <y.Type> (CMPQconst <TypeFlags> [16] y)))))
(Rsh16x32 <t> x y) -> (SARW <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPLconst <TypeFlags> [16] y)))))
(Rsh16x16 <t> x y) -> (SARW <t> x (ORW <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPWconst <TypeFlags> [16] y)))))
(Rsh16x8 <t> x y)  -> (SARW <t> x (ORB <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPBconst <TypeFlags> [16] y)))))

(Rsh8x64 <t> x y)  -> (SARB <t> x (ORQ <y.Type> y (NOTQ <y.Type> (SBBQcarrymask <y.Type> (CMPQconst <TypeFlags> [8] y)))))
(Rsh8x32 <t> x y)  -> (SARB <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPLconst <TypeFlags> [8] y)))))
(Rsh8x16 <t> x y)  -> (SARB <t> x (ORW <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPWconst <TypeFlags> [8] y)))))
(Rsh8x8 <t> x y)   -> (SARB <t> x (ORB <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPBconst <TypeFlags> [8] y)))))

(Less64 x y) -> (SETL (CMPQ <TypeFlags> x y))
(Less32 x y) -> (SETL (CMPL <TypeFlags> x y))
(Less16 x y) -> (SETL (CMPW <TypeFlags> x y))
(Less8  x y) -> (SETL (CMPB <TypeFlags> x y))

(Less64U x y) -> (SETB (CMPQ <TypeFlags> x y))
(Less32U x y) -> (SETB (CMPL <TypeFlags> x y))
(Less16U x y) -> (SETB (CMPW <TypeFlags> x y))
(Less8U  x y) -> (SETB (CMPB <TypeFlags> x y))

(Leq64 x y) -> (SETLE (CMPQ <TypeFlags> x y))
(Leq32 x y) -> (SETLE (CMPL <TypeFlags> x y))
(Leq16 x y) -> (SETLE (CMPW <TypeFlags> x y))
(Leq8  x y) -> (SETLE (CMPB <TypeFlags> x y))

(Leq64U x y) -> (SETBE (CMPQ <TypeFlags> x y))
(Leq32U x y) -> (SETBE (CMPL <TypeFlags> x y))
(Leq16U x y) -> (SETBE (CMPW <TypeFlags> x y))
(Leq8U  x y) -> (SETBE (CMPB <TypeFlags> x y))

(Greater64 x y) -> (SETG (CMPQ <TypeFlags> x y))
(Greater32 x y) -> (SETG (CMPL <TypeFlags> x y))
(Greater16 x y) -> (SETG (CMPW <TypeFlags> x y))
(Greater8  x y) -> (SETG (CMPB <TypeFlags> x y))

(Greater64U x y) -> (SETA (CMPQ <TypeFlags> x y))
(Greater32U x y) -> (SETA (CMPL <TypeFlags> x y))
(Greater16U x y) -> (SETA (CMPW <TypeFlags> x y))
(Greater8U  x y) -> (SETA (CMPB <TypeFlags> x y))

(Geq64 x y) -> (SETGE (CMPQ <TypeFlags> x y))
(Geq32 x y) -> (SETGE (CMPL <TypeFlags> x y))
(Geq16 x y) -> (SETGE (CMPW <TypeFlags> x y))
(Geq8  x y) -> (SETGE (CMPB <TypeFlags> x y))

(Geq64U x y) -> (SETAE (CMPQ <TypeFlags> x y))
(Geq32U x y) -> (SETAE (CMPL <TypeFlags> x y))
(Geq16U x y) -> (SETAE (CMPW <TypeFlags> x y))
(Geq8U  x y) -> (SETAE (CMPB <TypeFlags> x y))

(Eq64 x y) -> (SETEQ (CMPQ <TypeFlags> x y))
(Eq32 x y) -> (SETEQ (CMPL <TypeFlags> x y))
(Eq16 x y) -> (SETEQ (CMPW <TypeFlags> x y))
(Eq8 x y) -> (SETEQ (CMPB <TypeFlags> x y))
(EqPtr x y) -> (SETEQ (CMPQ <TypeFlags> x y))

(Neq64 x y) -> (SETNE (CMPQ <TypeFlags> x y))
(Neq32 x y) -> (SETNE (CMPL <TypeFlags> x y))
(Neq16 x y) -> (SETNE (CMPW <TypeFlags> x y))
(Neq8 x y) -> (SETNE (CMPB <TypeFlags> x y))
(NeqPtr x y) -> (SETNE (CMPQ <TypeFlags> x y))

(Load <t> ptr mem) && (is64BitInt(t) || isPtr(t)) -> (MOVQload ptr mem)
(Load <t> ptr mem) && is32BitInt(t) -> (MOVLload ptr mem)
(Load <t> ptr mem) && is16BitInt(t) -> (MOVWload ptr mem)
(Load <t> ptr mem) && (t.IsBoolean() || is8BitInt(t)) -> (MOVBload ptr mem)
(Store ptr val mem) && (is64BitInt(val.Type) || isPtr(val.Type)) -> (MOVQstore ptr val mem)
(Store ptr val mem) && is32BitInt(val.Type) -> (MOVLstore ptr val mem)
(Store ptr val mem) && is16BitInt(val.Type) -> (MOVWstore ptr val mem)
(Store ptr val mem) && is8BitInt(val.Type) -> (MOVBstore ptr val mem)
(Store ptr val mem) && val.Type.IsBoolean() -> (MOVBstore ptr val mem)

// checks
(IsNonNil p) -> (SETNE (TESTQ <TypeFlags> p p))
(IsInBounds idx len) -> (SETB (CMPQ <TypeFlags> idx len))

(Move [size] dst src mem) -> (REPMOVSB dst src (MOVQconst <config.Frontend().TypeUInt64()> [size]) mem)

(Not x) -> (XORBconst [1] x)

(OffPtr [off] ptr) -> (ADDQconst [off] ptr)

(Const8 [val]) -> (MOVBconst [val])
(Const16 [val]) -> (MOVWconst [val])
(Const32 [val]) -> (MOVLconst [val])
(Const64 [val]) -> (MOVQconst [val])
(ConstPtr [val]) -> (MOVQconst [val])
(ConstNil) -> (MOVQconst [0])
(ConstBool {b}) && !b.(bool) -> (MOVBconst [0])
(ConstBool {b}) && b.(bool) -> (MOVBconst [1])

(Addr {sym} base) -> (LEAQ {sym} base)

// block rewrites
(If (SETL cmp) yes no) -> (LT cmp yes no)
(If (SETLE cmp) yes no) -> (LE cmp yes no)
(If (SETG cmp) yes no) -> (GT cmp yes no)
(If (SETGE cmp) yes no) -> (GE cmp yes no)
(If (SETEQ cmp) yes no) -> (EQ cmp yes no)
(If (SETNE cmp) yes no) -> (NE cmp yes no)
(If (SETB cmp) yes no) -> (ULT cmp yes no)
(If (SETBE cmp) yes no) -> (ULE cmp yes no)
(If (SETA cmp) yes no) -> (UGT cmp yes no)
(If (SETAE cmp) yes no) -> (UGE cmp yes no)
(If cond yes no) && cond.Op == OpAMD64MOVBload -> (NE (TESTB <TypeFlags> cond cond) yes no)

(StaticCall [argwid] {target} mem) -> (CALLstatic [argwid] {target} mem)
(ClosureCall [argwid] entry closure mem) -> (CALLclosure [argwid] entry closure mem)

// Rules below here apply some simple optimizations after lowering.
// TODO: Should this be a separate pass?

// fold constants into instructions
(ADDQ x (MOVQconst [c])) && is32Bit(c) -> (ADDQconst [c] x)
(ADDQ (MOVQconst [c]) x) && is32Bit(c) -> (ADDQconst [c] x)
(ADDL x (MOVLconst [c])) -> (ADDLconst [c] x)
(ADDL (MOVLconst [c]) x) -> (ADDLconst [c] x)
(ADDW x (MOVWconst [c])) -> (ADDWconst [c] x)
(ADDW (MOVWconst [c]) x) -> (ADDWconst [c] x)
(ADDB x (MOVBconst [c])) -> (ADDBconst [c] x)
(ADDB (MOVBconst [c]) x) -> (ADDBconst [c] x)

(SUBQ x (MOVQconst [c])) && is32Bit(c) -> (SUBQconst x [c])
(SUBQ (MOVQconst [c]) x) && is32Bit(c) -> (NEGQ (SUBQconst <v.Type> x [c]))
(SUBL x (MOVLconst [c])) -> (SUBLconst x [c])
(SUBL (MOVLconst [c]) x) -> (NEGL (SUBLconst <v.Type> x [c]))
(SUBW x (MOVWconst [c])) -> (SUBWconst x [c])
(SUBW (MOVWconst [c]) x) -> (NEGW (SUBWconst <v.Type> x [c]))
(SUBB x (MOVBconst [c])) -> (SUBBconst x [c])
(SUBB (MOVBconst [c]) x) -> (NEGB (SUBBconst <v.Type> x [c]))

(MULQ x (MOVQconst [c])) && is32Bit(c) -> (MULQconst [c] x)
(MULQ (MOVQconst [c]) x) && is32Bit(c) -> (MULQconst [c] x)
(MULL x (MOVLconst [c])) -> (MULLconst [c] x)
(MULL (MOVLconst [c]) x) -> (MULLconst [c] x)
(MULW x (MOVWconst [c])) -> (MULWconst [c] x)
(MULW (MOVWconst [c]) x) -> (MULWconst [c] x)

(ANDQ x (MOVQconst [c])) && is32Bit(c) -> (ANDQconst [c] x)
(ANDQ (MOVQconst [c]) x) && is32Bit(c) -> (ANDQconst [c] x)
(ANDL x (MOVLconst [c])) -> (ANDLconst [c] x)
(ANDL (MOVLconst [c]) x) -> (ANDLconst [c] x)
(ANDW x (MOVWconst [c])) -> (ANDWconst [c] x)
(ANDW (MOVWconst [c]) x) -> (ANDWconst [c] x)
(ANDB x (MOVBconst [c])) -> (ANDBconst [c] x)
(ANDB (MOVBconst [c]) x) -> (ANDBconst [c] x)

(ORQ x (MOVQconst [c])) && is32Bit(c) -> (ORQconst [c] x)
(ORQ (MOVQconst [c]) x) && is32Bit(c) -> (ORQconst [c] x)
(ORL x (MOVLconst [c])) -> (ORLconst [c] x)
(ORL (MOVLconst [c]) x) -> (ORLconst [c] x)
(ORW x (MOVWconst [c])) -> (ORWconst [c] x)
(ORW (MOVWconst [c]) x) -> (ORWconst [c] x)
(ORB x (MOVBconst [c])) -> (ORBconst [c] x)
(ORB (MOVBconst [c]) x) -> (ORBconst [c] x)

(XORQ x (MOVQconst [c])) && is32Bit(c) -> (XORQconst [c] x)
(XORQ (MOVQconst [c]) x) && is32Bit(c) -> (XORQconst [c] x)
(XORL x (MOVLconst [c])) -> (XORLconst [c] x)
(XORL (MOVLconst [c]) x) -> (XORLconst [c] x)
(XORW x (MOVWconst [c])) -> (XORWconst [c] x)
(XORW (MOVWconst [c]) x) -> (XORWconst [c] x)
(XORB x (MOVBconst [c])) -> (XORBconst [c] x)
(XORB (MOVBconst [c]) x) -> (XORBconst [c] x)

(SHLQ x (MOVQconst [c])) -> (SHLQconst [c&63] x)
(SHLL x (MOVLconst [c])) -> (SHLLconst [c&31] x)
(SHLW x (MOVWconst [c])) -> (SHLWconst [c&31] x)
(SHLB x (MOVBconst [c])) -> (SHLBconst [c&31] x)

(SHRQ x (MOVQconst [c])) -> (SHRQconst [c&63] x)
(SHRL x (MOVLconst [c])) -> (SHRLconst [c&31] x)
(SHRW x (MOVWconst [c])) -> (SHRWconst [c&31] x)
(SHRB x (MOVBconst [c])) -> (SHRBconst [c&31] x)

(SARQ x (MOVQconst [c])) -> (SARQconst [c&63] x)
(SARL x (MOVLconst [c])) -> (SARLconst [c&31] x)
(SARW x (MOVWconst [c])) -> (SARWconst [c&31] x)
(SARB x (MOVBconst [c])) -> (SARBconst [c&31] x)

// Note: the word and byte shifts keep the low 5 bits (not the low 4 or 3 bits)
// because the x86 instructions are defined to use all 5 bits of the shift even
// for the small shifts.  I don't think we'll ever generate a weird shift (e.g.
// (SHLW x (MOVWconst [24])), but just in case.

(CMPQ x (MOVQconst [c])) && is32Bit(c) -> (CMPQconst x [c])
(CMPQ (MOVQconst [c]) x) && is32Bit(c) -> (InvertFlags (CMPQconst <TypeFlags> x [c]))
(CMPL x (MOVLconst [c])) -> (CMPLconst x [c])
(CMPL (MOVLconst [c]) x) -> (InvertFlags (CMPLconst <TypeFlags> x [c]))
(CMPW x (MOVWconst [c])) -> (CMPWconst x [c])
(CMPW (MOVWconst [c]) x) -> (InvertFlags (CMPWconst <TypeFlags> x [c]))
(CMPB x (MOVBconst [c])) -> (CMPBconst x [c])
(CMPB (MOVBconst [c]) x) -> (InvertFlags (CMPBconst <TypeFlags> x [c]))

// strength reduction
(MULQconst [-1] x) -> (NEGQ x)
(MULQconst [0] _) -> (MOVQconst [0])
(MULQconst [1] x) -> (Copy x)
(MULQconst [3] x) -> (LEAQ2 x x)
(MULQconst [5] x) -> (LEAQ4 x x)
(MULQconst [9] x) -> (LEAQ8 x x)
(MULQconst [c] x) && isPowerOfTwo(c) -> (SHLQconst [log2(c)] x)

// fold add/shift into leaq
(ADDQ x (SHLQconst [3] y)) -> (LEAQ8 x y)
(ADDQconst [c] (LEAQ8 [d] x y)) -> (LEAQ8 [addOff(c, d)] x y)

// reverse ordering of compare instruction
(SETL (InvertFlags x)) -> (SETG x)
(SETG (InvertFlags x)) -> (SETL x)
(SETB (InvertFlags x)) -> (SETA x)
(SETA (InvertFlags x)) -> (SETB x)
(SETLE (InvertFlags x)) -> (SETGE x)
(SETGE (InvertFlags x)) -> (SETLE x)
(SETBE (InvertFlags x)) -> (SETAE x)
(SETAE (InvertFlags x)) -> (SETBE x)
(SETEQ (InvertFlags x)) -> (SETEQ x)
(SETNE (InvertFlags x)) -> (SETNE x)

// sign extended loads
(MOVBQSX (MOVBload ptr mem)) -> (MOVBQSXload ptr mem)
(MOVBQZX (MOVBload ptr mem)) -> (MOVBQZXload ptr mem)
// TODO: more

// Don't extend before storing
(MOVLstore ptr (MOVLQSX x) mem) -> (MOVLstore ptr x mem)
(MOVWstore ptr (MOVWQSX x) mem) -> (MOVWstore ptr x mem)
(MOVBstore ptr (MOVBQSX x) mem) -> (MOVBstore ptr x mem)
(MOVLstore ptr (MOVLQZX x) mem) -> (MOVLstore ptr x mem)
(MOVWstore ptr (MOVWQZX x) mem) -> (MOVWstore ptr x mem)
(MOVBstore ptr (MOVBQZX x) mem) -> (MOVBstore ptr x mem)

// fold constants into memory operations
// Note that this is not always a good idea because if not all the uses of
// the ADDQconst get eliminated, we still have to compute the ADDQconst and we now
// have potentially two live values (ptr and (ADDQconst [off] ptr)) instead of one.
// Nevertheless, let's do it!
(MOVQload [off1] (ADDQconst [off2] ptr) mem) -> (MOVQload [addOff(off1, off2)] ptr mem)
(MOVQstore [off1] (ADDQconst [off2] ptr) val mem) -> (MOVQstore [addOff(off1, off2)] ptr val mem)

(MOVQload [off1] {sym1} (LEAQ [off2] {sym2} base) mem) && (sym1 == nil || sym2 == nil) ->
	  (MOVQload [addOff(off1,off2)] {mergeSym(sym1,sym2)} base mem)
(MOVQstore [off1] {sym1} (LEAQ [off2] {sym2} base) val mem) && (sym1 == nil || sym2 == nil) ->
	   (MOVQstore [addOff(off1,off2)] {mergeSym(sym1,sym2)} base val mem)

// indexed loads and stores
(MOVQload [off1] (LEAQ8 [off2] ptr idx) mem) -> (MOVQloadidx8 [addOff(off1, off2)] ptr idx mem)
(MOVQstore [off1] (LEAQ8 [off2] ptr idx) val mem) -> (MOVQstoreidx8 [addOff(off1, off2)] ptr idx val mem)

(MOVQloadidx8 [off1] (ADDQconst [off2] ptr) idx mem) -> (MOVQloadidx8 [addOff(off1, off2)] ptr idx mem)
(MOVQstoreidx8 [off1] (ADDQconst [off2] ptr) idx val mem) -> (MOVQstoreidx8 [addOff(off1, off2)] ptr idx val mem)

(ADDQconst [0] x) -> (Copy x)

// lower Zero instructions with word sizes
(Zero [0] _ mem) -> (Copy mem)
(Zero [1] destptr mem) -> (MOVBstore destptr (MOVBconst <config.Frontend().TypeInt8()> [0]) mem)
(Zero [2] destptr mem) -> (MOVWstore destptr (MOVWconst <config.Frontend().TypeInt16()> [0]) mem)
(Zero [4] destptr mem) -> (MOVLstore destptr (MOVLconst <config.Frontend().TypeInt32()> [0]) mem)
(Zero [8] destptr mem) -> (MOVQstore destptr (MOVQconst <config.Frontend().TypeInt64()> [0]) mem)

// rewrite anything less than 4 words into a series of MOV[BWLQ] $0, ptr(off) instructions
(Zero [size] destptr mem) && size < 4*8 -> (MOVXzero [size] destptr mem)
// Use STOSQ to zero memory. Rewrite this into storing the words with REPSTOSQ and then filling in the remainder with linear moves
(Zero [size] destptr mem) && size >= 4*8 -> (Zero [size%8] (OffPtr <config.Frontend().TypeUInt64()> [size-(size%8)] destptr) (REPSTOSQ  <TypeMem> destptr (MOVQconst <config.Frontend().TypeUInt64()> [size/8]) mem))

// Absorb InvertFlags into branches.
(LT (InvertFlags cmp) yes no) -> (GT cmp yes no)
(GT (InvertFlags cmp) yes no) -> (LT cmp yes no)
(LE (InvertFlags cmp) yes no) -> (GE cmp yes no)
(GE (InvertFlags cmp) yes no) -> (LE cmp yes no)
(ULT (InvertFlags cmp) yes no) -> (UGT cmp yes no)
(UGT (InvertFlags cmp) yes no) -> (ULT cmp yes no)
(ULE (InvertFlags cmp) yes no) -> (UGE cmp yes no)
(UGE (InvertFlags cmp) yes no) -> (ULE cmp yes no)
(EQ (InvertFlags cmp) yes no) -> (EQ cmp yes no)
(NE (InvertFlags cmp) yes no) -> (NE cmp yes no)

// get rid of overflow code for constant shifts
(SBBQcarrymask (CMPQconst [c] (MOVQconst [d]))) && inBounds(d, c) -> (MOVQconst [-1])
(SBBQcarrymask (CMPQconst [c] (MOVQconst [d]))) && !inBounds(d, c) -> (MOVQconst [0])
(SBBQcarrymask (CMPLconst [c] (MOVLconst [d]))) && inBounds(int64(int32(d)), int64(int32(c))) -> (MOVQconst [-1])
(SBBQcarrymask (CMPLconst [c] (MOVLconst [d]))) && !inBounds(int64(int32(d)), int64(int32(c))) -> (MOVQconst [0])
(SBBQcarrymask (CMPWconst [c] (MOVWconst [d]))) && inBounds(int64(int16(d)), int64(int16(c))) -> (MOVQconst [-1])
(SBBQcarrymask (CMPWconst [c] (MOVWconst [d]))) && !inBounds(int64(int16(d)), int64(int16(c))) -> (MOVQconst [0])
(SBBQcarrymask (CMPBconst [c] (MOVBconst [d]))) && inBounds(int64(int8(d)), int64(int8(c))) -> (MOVQconst [-1])
(SBBQcarrymask (CMPBconst [c] (MOVBconst [d]))) && !inBounds(int64(int8(d)), int64(int8(c))) -> (MOVQconst [0])
(ANDQconst [0] _)                 -> (MOVQconst [0])
(ANDLconst [c] _) && int32(c)==0  -> (MOVLconst [0])
(ANDWconst [c] _) && int16(c)==0  -> (MOVWconst [0])
(ANDBconst [c] _) && int8(c)==0   -> (MOVBconst [0])
(ANDQconst [-1] x)                -> (Copy x)
(ANDLconst [c] x) && int32(c)==-1 -> (Copy x)
(ANDWconst [c] x) && int16(c)==-1 -> (Copy x)
(ANDBconst [c] x) && int8(c)==-1  -> (Copy x)
(ORQconst [0] x)                  -> (Copy x)
(ORLconst [c] x) && int32(c)==0   -> (Copy x)
(ORWconst [c] x) && int16(c)==0   -> (Copy x)
(ORBconst [c] x) && int8(c)==0    -> (Copy x)
(ORQconst [-1] _)                 -> (MOVQconst [-1])
(ORLconst [c] _) && int32(c)==-1  -> (MOVLconst [-1])
(ORWconst [c] _) && int16(c)==-1  -> (MOVWconst [-1])
(ORBconst [c] _) && int8(c)==-1   -> (MOVBconst [-1])

// generic constant folding
// TODO: more of this
(ADDQconst [c] (MOVQconst [d])) -> (MOVQconst [c+d])
(ADDLconst [c] (MOVLconst [d])) -> (MOVLconst [c+d])
(ADDWconst [c] (MOVWconst [d])) -> (MOVWconst [c+d])
(ADDBconst [c] (MOVBconst [d])) -> (MOVBconst [c+d])
(ADDQconst [c] (ADDQconst [d] x)) -> (ADDQconst [c+d] x)
(ADDLconst [c] (ADDLconst [d] x)) -> (ADDLconst [c+d] x)
(ADDWconst [c] (ADDWconst [d] x)) -> (ADDWconst [c+d] x)
(ADDBconst [c] (ADDBconst [d] x)) -> (ADDBconst [c+d] x)
(SUBQconst [c] (MOVQconst [d])) -> (MOVQconst [c-d])
(SUBLconst [c] (MOVLconst [d])) -> (MOVLconst [c-d])
(SUBWconst [c] (MOVWconst [d])) -> (MOVWconst [c-d])
(SUBBconst [c] (MOVBconst [d])) -> (MOVBconst [c-d])
(SUBQconst [c] (SUBQconst [d] x)) -> (ADDQconst [c-d] x)
(SUBLconst [c] (SUBLconst [d] x)) -> (ADDLconst [c-d] x)
(SUBWconst [c] (SUBWconst [d] x)) -> (ADDWconst [c-d] x)
(SUBBconst [c] (SUBBconst [d] x)) -> (ADDBconst [c-d] x)
(NEGQ (MOVQconst [c])) -> (MOVQconst [-c])
(NEGL (MOVLconst [c])) -> (MOVLconst [-c])
(NEGW (MOVWconst [c])) -> (MOVWconst [-c])
(NEGB (MOVBconst [c])) -> (MOVBconst [-c])
(MULQconst [c] (MOVQconst [d])) -> (MOVQconst [c*d])
(MULLconst [c] (MOVLconst [d])) -> (MOVLconst [c*d])
(MULWconst [c] (MOVWconst [d])) -> (MOVWconst [c*d])
(ANDQconst [c] (MOVQconst [d])) -> (MOVQconst [c&d])
(ANDLconst [c] (MOVLconst [d])) -> (MOVLconst [c&d])
(ANDWconst [c] (MOVWconst [d])) -> (MOVWconst [c&d])
(ANDBconst [c] (MOVBconst [d])) -> (MOVBconst [c&d])
(ORQconst [c] (MOVQconst [d])) -> (MOVQconst [c|d])
(ORLconst [c] (MOVLconst [d])) -> (MOVLconst [c|d])
(ORWconst [c] (MOVWconst [d])) -> (MOVWconst [c|d])
(ORBconst [c] (MOVBconst [d])) -> (MOVBconst [c|d])
(XORQconst [c] (MOVQconst [d])) -> (MOVQconst [c^d])
(XORLconst [c] (MOVLconst [d])) -> (MOVLconst [c^d])
(XORWconst [c] (MOVWconst [d])) -> (MOVWconst [c^d])
(XORBconst [c] (MOVBconst [d])) -> (MOVBconst [c^d])
(NOTQ (MOVQconst [c])) -> (MOVQconst [^c])
(NOTL (MOVLconst [c])) -> (MOVLconst [^c])
(NOTW (MOVWconst [c])) -> (MOVWconst [^c])
(NOTB (MOVBconst [c])) -> (MOVBconst [^c])

// generic simplifications
// TODO: more of this
(ADDQ x (NEGQ y)) -> (SUBQ x y)
(ADDL x (NEGL y)) -> (SUBL x y)
(ADDW x (NEGW y)) -> (SUBW x y)
(ADDB x (NEGB y)) -> (SUBB x y)
(SUBQ x x) -> (MOVQconst [0])
(SUBL x x) -> (MOVLconst [0])
(SUBW x x) -> (MOVWconst [0])
(SUBB x x) -> (MOVBconst [0])
(ANDQ x x) -> (Copy x)
(ANDL x x) -> (Copy x)
(ANDW x x) -> (Copy x)
(ANDB x x) -> (Copy x)
(ORQ x x) -> (Copy x)
(ORL x x) -> (Copy x)
(ORW x x) -> (Copy x)
(ORB x x) -> (Copy x)
(XORQ x x) -> (MOVQconst [0])
(XORL x x) -> (MOVLconst [0])
(XORW x x) -> (MOVWconst [0])
(XORB x x) -> (MOVBconst [0])
