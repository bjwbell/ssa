This is a list of things that need to be worked on.  It will hopefully
be complete soon.

Coverage
--------
- Complex numbers
- Defer?
- Closure args
- PHEAP vars

Correctness
-----------
- GC maps
- Write barriers
- Debugging info
- Deferreturn
- Can/should we move control values out of their basic block?
- Anything to do for the race detector?
- Slicing details (avoid ptr to next object) [done for string]

Optimizations (better compiled code)
------------------------------------
- Reduce register pressure in scheduler
- More strength reduction: multiply -> shift/add combos (Worth doing?)
- Strength reduction: constant divides -> multiply
- Expand current optimizations to all bit widths
- Nil/bounds check removal
- Combining nil checks with subsequent load
- Implement memory zeroing with REPSTOSQ and DuffZero
- Implement memory copying with REPMOVSQ and DuffCopy
- Add a value range propagation pass (for bounds elim & bitwidth reduction)
- Stackalloc: organize values to allow good packing
- Regalloc: use arg slots as the home for arguments (don't copy args to locals)
- Reuse stack slots for noninterfering & compatible values (but see issue 8740)
- (x86) Combine loads into other ops
- (x86) More combining address arithmetic into loads/stores

Optimizations (better compiler)
-------------------------------
- Smaller Value.Type (int32 or ptr)?  Get rid of types altogether?
- Recycle dead Values (and Blocks) explicitly instead of using GC
- OpStore uses 3 args.  Increase the size of Value.argstorage to 3?
- Constant cache
- Reuseable slices (e.g. []int of size NumValues()) cached in Func
- Handle signed division overflow and sign extension earlier
- Implement 64 bit const division with high multiply, maybe in the frontend?
- Store bool and float32/float64 in auxInt

Regalloc
--------
- Make less arch-dependent
- Allow args and return values to be ssa-able
- Handle 2-address instructions
- Make liveness analysis non-quadratic
- Materialization of constants

Future/other
------------
- Start another architecture (arm?)
- 64-bit ops on 32-bit machines
- Investigate type equality. During SSA generation, should we use n.Type or (say) TypeBool?
- Should we get rid of named types in favor of underlying types during SSA generation?
- Should we introduce a new type equality routine that is less strict than the frontend's?
- Infrastructure for enabling/disabling/configuring passes
