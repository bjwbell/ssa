This is a list of things that need to be worked on.  It will hopefully
be complete soon.

Coverage
--------

Correctness
-----------
- Debugging info (check & fix as much as we can)
- Fix write barriers so cgo tests work (misc/cgo/errors/ptr.go)
- Re-enable TestStackBarrierProfiling (src/runtime/pprof/pprof_test.go)
- @ directive in rewrites might read overwritten data.  Save @loc
  in variable before modifying v.

Optimizations (better compiled code)
------------------------------------
- Reduce register pressure in scheduler
- More strength reduction: multiply -> shift/add combos (Worth doing?)
- Strength reduction: constant divides -> multiply
- Expand current optimizations to all bit widths
- Add a value range propagation pass (for bounds elim & bitwidth reduction)
- Make dead store pass inter-block
- (x86) More combining address arithmetic into loads/stores
- (x86) use ADDQ instead of LEAQ when we can
- redundant CMP in sequences like this:
  SUBQ $8, AX
  CMP AX, $0
  JEQ ...
- Use better write barrier calls
- If there are a lot of MOVQ $0, ..., then load
  0 into a register and use the register as the source instead.
- Allow arrays of length 1 (or longer, with all constant indexes?) to be SSAable.
- Figure out how to make PARAMOUT variables ssa-able.
  They need to get spilled automatically at end-of-function somehow.
- If strings are being passed around without being interpreted (ptr
  and len feilds being accessed) pass them in xmm registers?
  Same for interfaces?
- boolean logic: movb/xorb$1/testb/jeq -> movb/testb/jne
- (ADDQconst (SUBQconst x)) and vice-versa
- combine LEAQs
- store followed by load to same address
- (CMPconst [0] (AND x y)) -> (TEST x y)
- more (LOAD (ADDQ )) -> LOADIDX
- CMPL/SETEQ/TESTB/JEQ -> CMPL/JEQ
  CMPL/SETGE/TESTB/JEQ
- blockEQ (CMP x x)
- better computing of &&/|| in non-if/for contexts
- OpArrayIndex should take its index in AuxInt, not a full value.
- remove FLAGS from REP instruction clobbers
- (x86) Combine loads into other ops
  Note that this is challenging for ops that generate flags
  because flagalloc wants to move those instructions around for
  flag regeneration.
- In forms like if ... { call } else { no call }, mark the call branch as unlikely.
- Non-constant rotate detection.

Optimizations (better compiler)
-------------------------------
- Smaller Value.Type (int32 or ptr)?  Get rid of types altogether?
- Recycle dead Values (and Blocks) explicitly instead of using GC
- OpStore uses 3 args.  Increase the size of Value.argstorage to 3?
- Constant cache
- Reuseable slices (e.g. []int of size NumValues()) cached in Func
- Handle signed division overflow and sign extension earlier
- Implement 64 bit const division with high multiply, maybe in the frontend?
- Add bit widths to complex ops

Regalloc
--------
- Make less arch-dependent
- Allow return values to be ssa-able
- Handle 2-address instructions
- Make liveness analysis non-quadratic

Future/other
------------
- Start another architecture (arm?)
- 64-bit ops on 32-bit machines
- Investigate type equality. During SSA generation, should we use n.Type or (say) TypeBool?
- Should we get rid of named types in favor of underlying types during SSA generation?
- Should we introduce a new type equality routine that is less strict than the frontend's?
- Infrastructure for enabling/disabling/configuring passes
