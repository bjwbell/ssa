This is a list of things that need to be worked on.  It is by no means complete.

Allocation
- Allocation of decls in stackalloc.  Decls survive if they are
  addrtaken or are too large for registerization.

Scheduling
 - Make sure loads are scheduled correctly with respect to stores.
   Same for flag type values.  We can't have more than one value of
   mem or flag types live at once.
 - Reduce register pressure.  Schedule instructions which kill
   variables first.

Values
 - Store *Type instead of Type?  Keep an array of used Types in Func
   and reference by id?  Unify with the type ../gc so we just use a
   pointer instead of an interface?
 - Recycle dead values instead of using GC to do that.
 - A lot of Aux fields are just int64.  Add a separate AuxInt field?
   If not that, then cache the interfaces that wrap int64s.
 - OpStore uses 3 args.  Increase the size of argstorage to 3?

Regalloc
 - Make less arch-dependent
 - Don't spill everything at every basic block boundary.
 - Allow args and return values to be ssa-able.
 - Handle 2-address instructions.
 - Floating point registers
 - Make calls clobber all registers

Rewrites
 - Strength reduction (both arch-indep and arch-dependent?)
 - Start another architecture (arm?)
 - 64-bit ops on 32-bit machines
 - <regwidth ops.  For example, x+y on int32s on amd64 needs (MOVLQSX (ADDL x y)).
   Then add rewrites like (MOVLstore (MOVLQSX x) m) -> (MOVLstore x m)
   to get rid of most of the MOVLQSX.

Common-Subexpression Elimination
 - Make better decision about which value in an equivalence class we should
   choose to replace other values in that class.
 - Can we move control values out of their basic block?

Other
 - Write barriers
 - For testing, do something more sophisticated than
   checkOpcodeCounts.  Michael Matloob suggests using a similar
   pattern matcher to the rewrite engine to check for certain
   expression subtrees in the output.
