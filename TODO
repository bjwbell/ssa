This is a list of things that need to be worked on.  It is by no means complete.

Allocation
- Allocation of decls in stackalloc.  Decls survive if they are
  addrtaken or are too large for registerization.

Scheduling
 - Make sure loads are scheduled correctly with respect to stores.
   Same for flag type values.  We can't have more than one value of
   mem or flag types live at once.
 - Reduce register pressure.  Schedule instructions which kill
   variables first.

Values
 - Store *Type instead of Type?  Keep an array of used Types in Func
   and reference by id?  Unify with the type ../gc so we just use a
   pointer instead of an interface?
 - Recycle dead values instead of using GC to do that.
 - A lot of Aux fields are just int64.  Add a separate AuxInt field?
   If not that, then cache the interfaces that wrap int64s.
 - OpStore uses 3 args.  Increase the size of argstorage to 3?

Regalloc
 - Make less arch-dependent
 - Don't spill everything at every basic block boundary.
 - Allow args and return values to be ssa-able.
 - Handle 2-address instructions.
 - Floating point registers
 - Make calls clobber all registers
 - Make liveness analysis non-quadratic.

StackAlloc:
 - Sort variables so all ptr-containing ones are first (so stack
   maps are smaller)
 - Reuse stack slots for noninterfering and type-compatible variables
   (both AUTOs and spilled Values).  But see issue 8740 for what
   "type-compatible variables" mean and what DWARF information provides.

Rewrites
 - Strength reduction (both arch-indep and arch-dependent?)
 - Start another architecture (arm?)
 - 64-bit ops on 32-bit machines
 - <regwidth ops.  For example, x+y on int32s on amd64 needs (MOVLQSX (ADDL x y)).
   Then add rewrites like (MOVLstore (MOVLQSX x) m) -> (MOVLstore x m)
   to get rid of most of the MOVLQSX.
 - Determine which nil checks can be done implicitly (by faulting)
   and which need code generated, and do the code generation.

Common-Subexpression Elimination
 - Make better decision about which value in an equivalence class we should
   choose to replace other values in that class.
 - Can we move control values out of their basic block?
   This would break nilcheckelim as currently implemented,
   but it could be replaced by a similar CFG simplication pass.
 - Investigate type equality. During SSA generation, should we use n.Type or (say) TypeBool?
   Should we get rid of named types in favor of underlying types during SSA generation?
   Should we introduce a new type equality routine that is less strict than the frontend's?

Other
 - Write barriers
 - For testing, do something more sophisticated than
   checkOpcodeCounts.  Michael Matloob suggests using a similar
   pattern matcher to the rewrite engine to check for certain
   expression subtrees in the output.
 - Implement memory zeroing with REPSTOSQ and DuffZero
 - make deadstore work with zeroing.
 - Add a value range propagation optimization pass.
   Use it for bounds check elimination and bitwidth reduction.
 - Branch prediction: Respect hints from the frontend, add our own.
